/* main.c generated by valac 0.16.1, the Vala compiler
 * generated from main.vala, do not modify */

/* -*- Mode: Vala; indent-tabs-mode: nil; tab-width: 2 -*- */
/*
    This file is part of Déjà Dup.
    For copyright information, see AUTHORS.

    Déjà Dup is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Déjà Dup is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Déjà Dup.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <config.h>
#include <glib/gi18n-lib.h>
#include <common.h>
#include <widgets.h>
#include <gio/gio.h>
#include <gdk/gdk.h>


#define TYPE_DEJA_DUP_APP (deja_dup_app_get_type ())
#define DEJA_DUP_APP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DEJA_DUP_APP, DejaDupApp))
#define DEJA_DUP_APP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DEJA_DUP_APP, DejaDupAppClass))
#define IS_DEJA_DUP_APP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DEJA_DUP_APP))
#define IS_DEJA_DUP_APP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DEJA_DUP_APP))
#define DEJA_DUP_APP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DEJA_DUP_APP, DejaDupAppClass))

typedef struct _DejaDupApp DejaDupApp;
typedef struct _DejaDupAppClass DejaDupAppClass;
typedef struct _DejaDupAppPrivate DejaDupAppPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_option_context_free0(var) ((var == NULL) ? NULL : (var = (g_option_context_free (var), NULL)))

#define TYPE_ASSISTANT (assistant_get_type ())
#define ASSISTANT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ASSISTANT, Assistant))
#define ASSISTANT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ASSISTANT, AssistantClass))
#define IS_ASSISTANT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ASSISTANT))
#define IS_ASSISTANT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ASSISTANT))
#define ASSISTANT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ASSISTANT, AssistantClass))

typedef struct _Assistant Assistant;
typedef struct _AssistantClass AssistantClass;

#define TYPE_ASSISTANT_OPERATION (assistant_operation_get_type ())
#define ASSISTANT_OPERATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ASSISTANT_OPERATION, AssistantOperation))
#define ASSISTANT_OPERATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ASSISTANT_OPERATION, AssistantOperationClass))
#define IS_ASSISTANT_OPERATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ASSISTANT_OPERATION))
#define IS_ASSISTANT_OPERATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ASSISTANT_OPERATION))
#define ASSISTANT_OPERATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ASSISTANT_OPERATION, AssistantOperationClass))

typedef struct _AssistantOperation AssistantOperation;
typedef struct _AssistantOperationClass AssistantOperationClass;

#define TYPE_ASSISTANT_RESTORE (assistant_restore_get_type ())
#define ASSISTANT_RESTORE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ASSISTANT_RESTORE, AssistantRestore))
#define ASSISTANT_RESTORE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ASSISTANT_RESTORE, AssistantRestoreClass))
#define IS_ASSISTANT_RESTORE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ASSISTANT_RESTORE))
#define IS_ASSISTANT_RESTORE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ASSISTANT_RESTORE))
#define ASSISTANT_RESTORE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ASSISTANT_RESTORE, AssistantRestoreClass))

typedef struct _AssistantRestore AssistantRestore;
typedef struct _AssistantRestoreClass AssistantRestoreClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define __g_list_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_object_unref0_ (var), NULL)))

#define TYPE_ASSISTANT_BACKUP (assistant_backup_get_type ())
#define ASSISTANT_BACKUP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ASSISTANT_BACKUP, AssistantBackup))
#define ASSISTANT_BACKUP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ASSISTANT_BACKUP, AssistantBackupClass))
#define IS_ASSISTANT_BACKUP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ASSISTANT_BACKUP))
#define IS_ASSISTANT_BACKUP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ASSISTANT_BACKUP))
#define ASSISTANT_BACKUP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ASSISTANT_BACKUP, AssistantBackupClass))

typedef struct _AssistantBackup AssistantBackup;
typedef struct _AssistantBackupClass AssistantBackupClass;

#define TYPE_ASSISTANT_RESTORE_MISSING (assistant_restore_missing_get_type ())
#define ASSISTANT_RESTORE_MISSING(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ASSISTANT_RESTORE_MISSING, AssistantRestoreMissing))
#define ASSISTANT_RESTORE_MISSING_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ASSISTANT_RESTORE_MISSING, AssistantRestoreMissingClass))
#define IS_ASSISTANT_RESTORE_MISSING(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ASSISTANT_RESTORE_MISSING))
#define IS_ASSISTANT_RESTORE_MISSING_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ASSISTANT_RESTORE_MISSING))
#define ASSISTANT_RESTORE_MISSING_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ASSISTANT_RESTORE_MISSING, AssistantRestoreMissingClass))

typedef struct _AssistantRestoreMissing AssistantRestoreMissing;
typedef struct _AssistantRestoreMissingClass AssistantRestoreMissingClass;

struct _DejaDupApp {
	GObject parent_instance;
	DejaDupAppPrivate * priv;
};

struct _DejaDupAppClass {
	GObjectClass parent_class;
};


extern GtkWindow* toplevel;
GtkWindow* toplevel = NULL;
static gpointer deja_dup_app_parent_class = NULL;
static gboolean deja_dup_app_show_version;
static gboolean deja_dup_app_show_version = FALSE;
static gboolean deja_dup_app_restore_mode;
static gboolean deja_dup_app_restore_mode = FALSE;
static gboolean deja_dup_app_backup_mode;
static gboolean deja_dup_app_backup_mode = FALSE;
static gboolean deja_dup_app_automatic;
static gboolean deja_dup_app_automatic = FALSE;
static gboolean deja_dup_app_restoremissing_mode;
static gboolean deja_dup_app_restoremissing_mode = FALSE;
static gboolean deja_dup_app_prompt_mode;
static gboolean deja_dup_app_prompt_mode = FALSE;
static gchar** deja_dup_app_filenames;
static gint deja_dup_app_filenames_length1;
static gchar** deja_dup_app_filenames = NULL;
static gint deja_dup_app_filenames_length1 = 0;
static gint _deja_dup_app_filenames_size_ = 0;

GType deja_dup_app_get_type (void) G_GNUC_CONST;
enum  {
	DEJA_DUP_APP_DUMMY_PROPERTY
};
static gboolean deja_dup_app_handle_console_options (gint* status);
gint deja_dup_app_main (gchar** args, int args_length1);
AssistantRestore* assistant_restore_new_with_files (GList* files);
AssistantRestore* assistant_restore_construct_with_files (GType object_type, GList* files);
GType assistant_get_type (void) G_GNUC_CONST;
GType assistant_operation_get_type (void) G_GNUC_CONST;
GType assistant_restore_get_type (void) G_GNUC_CONST;
static void _g_object_unref0_ (gpointer var);
static void _g_list_free__g_object_unref0_ (GList* self);
AssistantBackup* assistant_backup_new (gboolean automatic);
AssistantBackup* assistant_backup_construct (GType object_type, gboolean automatic);
GType assistant_backup_get_type (void) G_GNUC_CONST;
AssistantRestoreMissing* assistant_restore_missing_new (GFile* list_dir);
AssistantRestoreMissing* assistant_restore_missing_construct (GType object_type, GFile* list_dir);
GType assistant_restore_missing_get_type (void) G_GNUC_CONST;
GtkWindow* prompt (void);
static void _gtk_main_quit_gtk_widget_destroy (GtkWidget* _sender, gpointer self);
DejaDupApp* deja_dup_app_new (void);
DejaDupApp* deja_dup_app_construct (GType object_type);
static void deja_dup_app_finalize (GObject* obj);

static const GOptionEntry DEJA_DUP_APP_options[8] = {{"version", (gchar) 0, 0, G_OPTION_ARG_NONE, &deja_dup_app_show_version, "Show version", NULL}, {"restore", (gchar) 0, 0, G_OPTION_ARG_NONE, &deja_dup_app_restore_mode, "Restore given files", NULL}, {"backup", (gchar) 0, 0, G_OPTION_ARG_NONE, &deja_dup_app_backup_mode, "Immediately start a backup", NULL}, {"auto", (gchar) 0, (gint) G_OPTION_FLAG_HIDDEN, G_OPTION_ARG_NONE, &deja_dup_app_automatic, NULL, NULL}, {"restore-missing", (gchar) 0, 0, G_OPTION_ARG_NONE, &deja_dup_app_restoremissing_mode, "Restore deleted files", NULL}, {"prompt", (gchar) 0, (gint) G_OPTION_FLAG_HIDDEN, G_OPTION_ARG_NONE, &deja_dup_app_prompt_mode, NULL, NULL}, {"", (gchar) 0, 0, G_OPTION_ARG_FILENAME_ARRAY, &deja_dup_app_filenames, NULL, NULL}, {NULL}};

static gboolean deja_dup_app_handle_console_options (gint* status) {
	gint _vala_status = 0;
	gboolean result = FALSE;
	gboolean _tmp0_;
	gboolean _tmp1_;
	_vala_status = 0;
	_tmp0_ = deja_dup_app_show_version;
	if (_tmp0_) {
		g_print ("%s %s\n", "deja-dup", VERSION);
		result = FALSE;
		if (status) {
			*status = _vala_status;
		}
		return result;
	}
	_tmp1_ = deja_dup_app_restoremissing_mode;
	if (_tmp1_) {
		gchar** _tmp2_;
		gint _tmp2__length1;
		_tmp2_ = deja_dup_app_filenames;
		_tmp2__length1 = deja_dup_app_filenames_length1;
		if (_tmp2_ == NULL) {
			const gchar* _tmp3_ = NULL;
			_tmp3_ = _ ("No directory provided");
			g_printerr ("%s\n", _tmp3_);
			_vala_status = 1;
			result = FALSE;
			if (status) {
				*status = _vala_status;
			}
			return result;
		} else {
			gchar** _tmp4_;
			gint _tmp4__length1;
			_tmp4_ = deja_dup_app_filenames;
			_tmp4__length1 = deja_dup_app_filenames_length1;
			if (_tmp4__length1 > 1) {
				const gchar* _tmp5_ = NULL;
				_tmp5_ = _ ("Only one directory can be shown at once");
				g_printerr ("%s\n", _tmp5_);
				_vala_status = 1;
				result = FALSE;
				if (status) {
					*status = _vala_status;
				}
				return result;
			}
		}
	}
	result = TRUE;
	if (status) {
		*status = _vala_status;
	}
	return result;
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void _g_list_free__g_object_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_list_free (self);
}


static void _gtk_main_quit_gtk_widget_destroy (GtkWidget* _sender, gpointer self) {
	gtk_main_quit ();
}


gint deja_dup_app_main (gchar** args, int args_length1) {
	gint result = 0;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar* modes;
	const gchar* _tmp4_;
	GOptionContext* _tmp5_;
	GOptionContext* context;
	GOptionContext* _tmp6_;
	const gchar* _tmp7_ = NULL;
	GOptionContext* _tmp8_;
	GOptionContext* _tmp9_;
	GOptionGroup* _tmp10_ = NULL;
	gint status = 0;
	gint _tmp17_ = 0;
	gboolean _tmp18_ = FALSE;
	GtkIconTheme* _tmp19_ = NULL;
	gboolean _tmp20_ = FALSE;
	gboolean _tmp21_;
	GtkWindow* _tmp61_;
	GError * _inner_error_ = NULL;
	deja_dup_i18n_setup ();
	_tmp0_ = _ ("Déjà Dup Backup Tool");
	g_set_application_name (_tmp0_);
	_tmp1_ = _ ("[FILES…]");
	_tmp2_ = _ ("DIRECTORY");
	_tmp3_ = g_strdup_printf ("\n  %s --backup\n  %s --restore %s\n  %s --restore-missing %s", PACKAGE, PACKAGE, _tmp1_, PACKAGE, _tmp2_);
	modes = _tmp3_;
	_tmp4_ = modes;
	_tmp5_ = g_option_context_new (_tmp4_);
	context = _tmp5_;
	_tmp6_ = context;
	_tmp7_ = _ ("Déjà Dup is a simple backup tool.  It hides the complexity of backing " \
"up\n" \
"the Right Way (encrypted, off-site, and regular) and uses duplicity as" \
"\n" \
"the backend.");
	g_option_context_set_summary (_tmp6_, _tmp7_);
	_tmp8_ = context;
	g_option_context_add_main_entries (_tmp8_, DEJA_DUP_APP_options, GETTEXT_PACKAGE);
	_tmp9_ = context;
	_tmp10_ = gtk_get_option_group (FALSE);
	g_option_context_add_group (_tmp9_, _tmp10_);
	{
		GOptionContext* _tmp11_;
		_tmp11_ = context;
		g_option_context_parse (_tmp11_, &args_length1, &args, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch12_g_error;
		}
	}
	goto __finally12;
	__catch12_g_error:
	{
		GError* e = NULL;
		GError* _tmp12_;
		const gchar* _tmp13_;
		GOptionContext* _tmp14_;
		gchar* _tmp15_ = NULL;
		gchar* _tmp16_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp12_ = e;
		_tmp13_ = _tmp12_->message;
		_tmp14_ = context;
		_tmp15_ = g_option_context_get_help (_tmp14_, TRUE, NULL);
		_tmp16_ = _tmp15_;
		g_printerr ("%s\n\n%s", _tmp13_, _tmp16_);
		_g_free0 (_tmp16_);
		result = 1;
		_g_error_free0 (e);
		_g_option_context_free0 (context);
		_g_free0 (modes);
		return result;
	}
	__finally12:
	if (_inner_error_ != NULL) {
		_g_option_context_free0 (context);
		_g_free0 (modes);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	_tmp18_ = deja_dup_app_handle_console_options (&_tmp17_);
	status = _tmp17_;
	if (!_tmp18_) {
		result = status;
		_g_option_context_free0 (context);
		_g_free0 (modes);
		return result;
	}
	gtk_init (&args_length1, &args);
	_tmp19_ = gtk_icon_theme_get_default ();
	gtk_icon_theme_append_search_path (_tmp19_, THEME_DIR);
	gtk_window_set_default_icon_name (PACKAGE);
	_tmp20_ = deja_dup_gui_initialize (NULL, TRUE);
	if (!_tmp20_) {
		result = 1;
		_g_option_context_free0 (context);
		_g_free0 (modes);
		return result;
	}
	_tmp21_ = deja_dup_app_restore_mode;
	if (_tmp21_) {
		GList* file_list;
		gchar** _tmp22_;
		gint _tmp22__length1;
		GList* _tmp32_;
		AssistantRestore* _tmp33_;
		GtkWindow* _tmp34_;
		GtkWindow* _tmp35_;
		file_list = NULL;
		_tmp22_ = deja_dup_app_filenames;
		_tmp22__length1 = deja_dup_app_filenames_length1;
		if (_tmp22_ != NULL) {
			gint i;
			i = 0;
			while (TRUE) {
				gchar** _tmp23_;
				gint _tmp23__length1;
				gint _tmp24_;
				const gchar* _tmp25_;
				gchar** _tmp26_;
				gint _tmp26__length1;
				gint _tmp27_;
				const gchar* _tmp28_;
				GFile* _tmp29_ = NULL;
				_tmp23_ = deja_dup_app_filenames;
				_tmp23__length1 = deja_dup_app_filenames_length1;
				_tmp24_ = i;
				_tmp25_ = _tmp23_[_tmp24_];
				if (!(_tmp25_ != NULL)) {
					break;
				}
				_tmp26_ = deja_dup_app_filenames;
				_tmp26__length1 = deja_dup_app_filenames_length1;
				_tmp27_ = i;
				i = _tmp27_ + 1;
				_tmp28_ = _tmp26_[_tmp27_];
				_tmp29_ = g_file_new_for_commandline_arg (_tmp28_);
				file_list = g_list_append (file_list, _tmp29_);
			}
		} else {
			gchar* _tmp30_ = NULL;
			gchar* last_run;
			const gchar* _tmp31_;
			_tmp30_ = deja_dup_last_run_date (DEJA_DUP_TIMESTAMP_TYPE_BACKUP);
			last_run = _tmp30_;
			_tmp31_ = last_run;
			if (g_strcmp0 (_tmp31_, "") != 0) {
				deja_dup_set_settings_read_only (TRUE);
			}
			_g_free0 (last_run);
		}
		_tmp32_ = file_list;
		_tmp33_ = assistant_restore_new_with_files (_tmp32_);
		_tmp34_ = (GtkWindow*) g_object_ref_sink (_tmp33_);
		_g_object_unref0 (toplevel);
		toplevel = _tmp34_;
		_tmp35_ = toplevel;
		gtk_widget_show_all ((GtkWidget*) _tmp35_);
		__g_list_free__g_object_unref0_0 (file_list);
	} else {
		gboolean _tmp36_;
		_tmp36_ = deja_dup_app_backup_mode;
		if (_tmp36_) {
			gboolean _tmp37_;
			AssistantBackup* _tmp38_;
			GtkWindow* _tmp39_;
			_tmp37_ = deja_dup_app_automatic;
			_tmp38_ = assistant_backup_new (_tmp37_);
			_tmp39_ = (GtkWindow*) g_object_ref_sink (_tmp38_);
			_g_object_unref0 (toplevel);
			toplevel = _tmp39_;
			gdk_notify_startup_complete ();
		} else {
			gboolean _tmp40_;
			_tmp40_ = deja_dup_app_restoremissing_mode;
			if (_tmp40_) {
				gchar** _tmp41_;
				gint _tmp41__length1;
				const gchar* _tmp42_;
				GFile* _tmp43_ = NULL;
				GFile* list_directory;
				GFile* _tmp44_;
				gboolean _tmp45_ = FALSE;
				GFile* _tmp47_;
				GFileType _tmp48_ = 0;
				GFile* _tmp50_;
				AssistantRestoreMissing* _tmp51_;
				GtkWindow* _tmp52_;
				GtkWindow* _tmp53_;
				_tmp41_ = deja_dup_app_filenames;
				_tmp41__length1 = deja_dup_app_filenames_length1;
				_tmp42_ = _tmp41_[0];
				_tmp43_ = g_file_new_for_commandline_arg (_tmp42_);
				list_directory = _tmp43_;
				_tmp44_ = list_directory;
				_tmp45_ = g_file_query_exists (_tmp44_, NULL);
				if (!_tmp45_) {
					const gchar* _tmp46_ = NULL;
					_tmp46_ = _ ("Directory does not exists");
					g_printerr ("%s\n", _tmp46_);
					result = 1;
					_g_object_unref0 (list_directory);
					_g_option_context_free0 (context);
					_g_free0 (modes);
					return result;
				}
				_tmp47_ = list_directory;
				_tmp48_ = g_file_query_file_type (_tmp47_, 0, NULL);
				if (_tmp48_ != G_FILE_TYPE_DIRECTORY) {
					const gchar* _tmp49_ = NULL;
					_tmp49_ = _ ("You must provide a directory, not a file");
					g_printerr ("%s\n", _tmp49_);
					result = 1;
					_g_object_unref0 (list_directory);
					_g_option_context_free0 (context);
					_g_free0 (modes);
					return result;
				}
				_tmp50_ = list_directory;
				_tmp51_ = assistant_restore_missing_new (_tmp50_);
				_tmp52_ = (GtkWindow*) g_object_ref_sink (_tmp51_);
				_g_object_unref0 (toplevel);
				toplevel = _tmp52_;
				_tmp53_ = toplevel;
				gtk_widget_show_all ((GtkWidget*) _tmp53_);
				_g_object_unref0 (list_directory);
			} else {
				gboolean _tmp54_;
				_tmp54_ = deja_dup_app_prompt_mode;
				if (_tmp54_) {
					GtkWindow* _tmp55_ = NULL;
					GtkWindow* _tmp56_;
					_tmp55_ = prompt ();
					_g_object_unref0 (toplevel);
					toplevel = _tmp55_;
					_tmp56_ = toplevel;
					if (_tmp56_ == NULL) {
						result = 0;
						_g_option_context_free0 (context);
						_g_free0 (modes);
						return result;
					}
				} else {
					const gchar* _tmp57_ = NULL;
					GOptionContext* _tmp58_;
					gchar* _tmp59_ = NULL;
					gchar* _tmp60_;
					_tmp57_ = _ ("You must specify a mode");
					_tmp58_ = context;
					_tmp59_ = g_option_context_get_help (_tmp58_, TRUE, NULL);
					_tmp60_ = _tmp59_;
					g_printerr ("%s\n\n%s", _tmp57_, _tmp60_);
					_g_free0 (_tmp60_);
					result = 1;
					_g_option_context_free0 (context);
					_g_free0 (modes);
					return result;
				}
			}
		}
	}
	_tmp61_ = toplevel;
	g_signal_connect ((GtkWidget*) _tmp61_, "destroy", (GCallback) _gtk_main_quit_gtk_widget_destroy, NULL);
	gtk_main ();
	result = 0;
	_g_option_context_free0 (context);
	_g_free0 (modes);
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return deja_dup_app_main (argv, argc);
}


DejaDupApp* deja_dup_app_construct (GType object_type) {
	DejaDupApp * self = NULL;
	self = (DejaDupApp*) g_object_new (object_type, NULL);
	return self;
}


DejaDupApp* deja_dup_app_new (void) {
	return deja_dup_app_construct (TYPE_DEJA_DUP_APP);
}


static void deja_dup_app_class_init (DejaDupAppClass * klass) {
	deja_dup_app_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = deja_dup_app_finalize;
}


static void deja_dup_app_instance_init (DejaDupApp * self) {
}


static void deja_dup_app_finalize (GObject* obj) {
	DejaDupApp * self;
	self = DEJA_DUP_APP (obj);
	G_OBJECT_CLASS (deja_dup_app_parent_class)->finalize (obj);
}


GType deja_dup_app_get_type (void) {
	static volatile gsize deja_dup_app_type_id__volatile = 0;
	if (g_once_init_enter (&deja_dup_app_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (DejaDupAppClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) deja_dup_app_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (DejaDupApp), 0, (GInstanceInitFunc) deja_dup_app_instance_init, NULL };
		GType deja_dup_app_type_id;
		deja_dup_app_type_id = g_type_register_static (G_TYPE_OBJECT, "DejaDupApp", &g_define_type_info, 0);
		g_once_init_leave (&deja_dup_app_type_id__volatile, deja_dup_app_type_id);
	}
	return deja_dup_app_type_id__volatile;
}



