/* DuplicityPlugin.c generated by valac 0.16.1, the Vala compiler
 * generated from DuplicityPlugin.vala, do not modify */

/* -*- Mode: Vala; indent-tabs-mode: nil; tab-width: 2 -*- */
/*
    This file is part of Déjà Dup.
    For copyright information, see AUTHORS.

    Déjà Dup is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Déjà Dup is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Déjà Dup.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <glib.h>
#include <glib-object.h>
#include <common.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gi18n-lib.h>
#include <libpeas/peas.h>


#define TYPE_DUPLICITY_PLUGIN (duplicity_plugin_get_type ())
#define DUPLICITY_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DUPLICITY_PLUGIN, DuplicityPlugin))
#define DUPLICITY_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DUPLICITY_PLUGIN, DuplicityPluginClass))
#define IS_DUPLICITY_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DUPLICITY_PLUGIN))
#define IS_DUPLICITY_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DUPLICITY_PLUGIN))
#define DUPLICITY_PLUGIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DUPLICITY_PLUGIN, DuplicityPluginClass))

typedef struct _DuplicityPlugin DuplicityPlugin;
typedef struct _DuplicityPluginClass DuplicityPluginClass;
typedef struct _DuplicityPluginPrivate DuplicityPluginPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_DUPLICITY_JOB (duplicity_job_get_type ())
#define DUPLICITY_JOB(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DUPLICITY_JOB, DuplicityJob))
#define DUPLICITY_JOB_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DUPLICITY_JOB, DuplicityJobClass))
#define IS_DUPLICITY_JOB(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DUPLICITY_JOB))
#define IS_DUPLICITY_JOB_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DUPLICITY_JOB))
#define DUPLICITY_JOB_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DUPLICITY_JOB, DuplicityJobClass))

typedef struct _DuplicityJob DuplicityJob;
typedef struct _DuplicityJobClass DuplicityJobClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

struct _DuplicityPlugin {
	DejaDupToolPlugin parent_instance;
	DuplicityPluginPrivate * priv;
};

struct _DuplicityPluginClass {
	DejaDupToolPluginClass parent_class;
};

struct _DuplicityPluginPrivate {
	gboolean has_been_setup;
};


static gpointer duplicity_plugin_parent_class = NULL;
static GType duplicity_plugin_type_id = 0;

GType duplicity_plugin_get_type (void) G_GNUC_CONST;
GType duplicity_plugin_register_type (GTypeModule * module);
#define DUPLICITY_PLUGIN_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_DUPLICITY_PLUGIN, DuplicityPluginPrivate))
enum  {
	DUPLICITY_PLUGIN_DUMMY_PROPERTY
};
#define DUPLICITY_PLUGIN_REQUIRED_MAJOR 0
#define DUPLICITY_PLUGIN_REQUIRED_MINOR 6
#define DUPLICITY_PLUGIN_REQUIRED_MICRO 14
static void duplicity_plugin_do_initial_setup (DuplicityPlugin* self, GError** error);
static DejaDupToolJob* duplicity_plugin_real_create_job (DejaDupToolPlugin* base, GError** error);
DuplicityJob* duplicity_job_new (void);
DuplicityJob* duplicity_job_construct (GType object_type);
GType duplicity_job_get_type (void) G_GNUC_CONST;
GType duplicity_job_register_type (GTypeModule * module);
DuplicityPlugin* duplicity_plugin_new (void);
DuplicityPlugin* duplicity_plugin_construct (GType object_type);
static GObject * duplicity_plugin_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void duplicity_plugin_finalize (GObject* obj);
void peas_register_types (GTypeModule* module);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


static gchar* string_strip (const gchar* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _result_;
	const gchar* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	_tmp1_ = _result_;
	g_strstrip (_tmp1_);
	result = _result_;
	return result;
}


static void duplicity_plugin_do_initial_setup (DuplicityPlugin* self, GError** error) {
	gchar* output = NULL;
	gchar* _tmp0_ = NULL;
	const gchar* _tmp1_;
	gchar** _tmp2_;
	gchar** _tmp3_ = NULL;
	gchar** tokens;
	gint tokens_length1;
	gint _tokens_size_;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp5_ = FALSE;
	gchar** _tmp6_;
	gint _tmp6__length1;
	gboolean _tmp9_;
	gboolean _tmp12_;
	gchar** _tmp15_;
	gint _tmp15__length1;
	const gchar* _tmp16_;
	gchar* _tmp17_ = NULL;
	gchar* version_string;
	const gchar* _tmp18_;
	gchar** _tmp19_;
	gchar** _tmp20_ = NULL;
	gchar** ver_tokens;
	gint ver_tokens_length1;
	gint _ver_tokens_size_;
	gboolean _tmp21_ = FALSE;
	gchar** _tmp22_;
	gint _tmp22__length1;
	gboolean _tmp25_;
	gint major;
	gint minor;
	gint micro;
	gchar** _tmp32_;
	gint _tmp32__length1;
	const gchar* _tmp33_;
	gint _tmp34_ = 0;
	gchar** _tmp35_;
	gint _tmp35__length1;
	const gchar* _tmp36_;
	gboolean _tmp45_ = FALSE;
	gboolean _tmp46_ = FALSE;
	gint _tmp47_;
	gboolean _tmp52_;
	gboolean _tmp60_;
	gboolean meets;
	gboolean _tmp61_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_spawn_command_line_sync ("duplicity --version", &_tmp0_, NULL, NULL, &_inner_error_);
	_g_free0 (output);
	output = _tmp0_;
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		_g_free0 (output);
		return;
	}
	_tmp1_ = output;
	_tmp3_ = _tmp2_ = g_strsplit (_tmp1_, " ", 2);
	tokens = _tmp3_;
	tokens_length1 = _vala_array_length (_tmp2_);
	_tokens_size_ = tokens_length1;
	_tmp6_ = tokens;
	_tmp6__length1 = tokens_length1;
	if (_tmp6_ == NULL) {
		_tmp5_ = TRUE;
	} else {
		gchar** _tmp7_;
		gint _tmp7__length1;
		const gchar* _tmp8_;
		_tmp7_ = tokens;
		_tmp7__length1 = tokens_length1;
		_tmp8_ = _tmp7_[0];
		_tmp5_ = _tmp8_ == NULL;
	}
	_tmp9_ = _tmp5_;
	if (_tmp9_) {
		_tmp4_ = TRUE;
	} else {
		gchar** _tmp10_;
		gint _tmp10__length1;
		const gchar* _tmp11_;
		_tmp10_ = tokens;
		_tmp10__length1 = tokens_length1;
		_tmp11_ = _tmp10_[1];
		_tmp4_ = _tmp11_ == NULL;
	}
	_tmp12_ = _tmp4_;
	if (_tmp12_) {
		const gchar* _tmp13_ = NULL;
		GError* _tmp14_;
		_tmp13_ = _ ("Could not understand duplicity version.");
		_tmp14_ = g_error_new_literal (G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED, _tmp13_);
		_inner_error_ = _tmp14_;
		g_propagate_error (error, _inner_error_);
		tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (output);
		return;
	}
	_tmp15_ = tokens;
	_tmp15__length1 = tokens_length1;
	_tmp16_ = _tmp15_[1];
	_tmp17_ = string_strip (_tmp16_);
	version_string = _tmp17_;
	_tmp18_ = version_string;
	_tmp20_ = _tmp19_ = g_strsplit (_tmp18_, ".", 0);
	ver_tokens = _tmp20_;
	ver_tokens_length1 = _vala_array_length (_tmp19_);
	_ver_tokens_size_ = ver_tokens_length1;
	_tmp22_ = ver_tokens;
	_tmp22__length1 = ver_tokens_length1;
	if (_tmp22_ == NULL) {
		_tmp21_ = TRUE;
	} else {
		gchar** _tmp23_;
		gint _tmp23__length1;
		const gchar* _tmp24_;
		_tmp23_ = ver_tokens;
		_tmp23__length1 = ver_tokens_length1;
		_tmp24_ = _tmp23_[0];
		_tmp21_ = _tmp24_ == NULL;
	}
	_tmp25_ = _tmp21_;
	if (_tmp25_) {
		const gchar* _tmp26_ = NULL;
		const gchar* _tmp27_;
		gchar* _tmp28_ = NULL;
		gchar* _tmp29_;
		GError* _tmp30_;
		GError* _tmp31_;
		_tmp26_ = _ ("Could not understand duplicity version ‘%s’.");
		_tmp27_ = version_string;
		_tmp28_ = g_strdup_printf (_tmp26_, _tmp27_);
		_tmp29_ = _tmp28_;
		_tmp30_ = g_error_new_literal (G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED, _tmp29_);
		_tmp31_ = _tmp30_;
		_g_free0 (_tmp29_);
		_inner_error_ = _tmp31_;
		g_propagate_error (error, _inner_error_);
		ver_tokens = (_vala_array_free (ver_tokens, ver_tokens_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (version_string);
		tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (output);
		return;
	}
	major = 0;
	minor = 0;
	micro = 0;
	_tmp32_ = ver_tokens;
	_tmp32__length1 = ver_tokens_length1;
	_tmp33_ = _tmp32_[0];
	_tmp34_ = atoi (_tmp33_);
	major = _tmp34_;
	_tmp35_ = ver_tokens;
	_tmp35__length1 = ver_tokens_length1;
	_tmp36_ = _tmp35_[1];
	if (_tmp36_ != NULL) {
		gchar** _tmp37_;
		gint _tmp37__length1;
		const gchar* _tmp38_;
		gint _tmp39_ = 0;
		gchar** _tmp40_;
		gint _tmp40__length1;
		const gchar* _tmp41_;
		_tmp37_ = ver_tokens;
		_tmp37__length1 = ver_tokens_length1;
		_tmp38_ = _tmp37_[1];
		_tmp39_ = atoi (_tmp38_);
		minor = _tmp39_;
		_tmp40_ = ver_tokens;
		_tmp40__length1 = ver_tokens_length1;
		_tmp41_ = _tmp40_[2];
		if (_tmp41_ != NULL) {
			gchar** _tmp42_;
			gint _tmp42__length1;
			const gchar* _tmp43_;
			gint _tmp44_ = 0;
			_tmp42_ = ver_tokens;
			_tmp42__length1 = ver_tokens_length1;
			_tmp43_ = _tmp42_[2];
			_tmp44_ = atoi (_tmp43_);
			micro = _tmp44_;
		}
	}
	_tmp47_ = major;
	if (_tmp47_ > DUPLICITY_PLUGIN_REQUIRED_MAJOR) {
		_tmp46_ = TRUE;
	} else {
		gboolean _tmp48_ = FALSE;
		gint _tmp49_;
		gboolean _tmp51_;
		_tmp49_ = major;
		if (_tmp49_ == DUPLICITY_PLUGIN_REQUIRED_MAJOR) {
			gint _tmp50_;
			_tmp50_ = minor;
			_tmp48_ = _tmp50_ > DUPLICITY_PLUGIN_REQUIRED_MINOR;
		} else {
			_tmp48_ = FALSE;
		}
		_tmp51_ = _tmp48_;
		_tmp46_ = _tmp51_;
	}
	_tmp52_ = _tmp46_;
	if (_tmp52_) {
		_tmp45_ = TRUE;
	} else {
		gboolean _tmp53_ = FALSE;
		gboolean _tmp54_ = FALSE;
		gint _tmp55_;
		gboolean _tmp57_;
		gboolean _tmp59_;
		_tmp55_ = major;
		if (_tmp55_ == DUPLICITY_PLUGIN_REQUIRED_MAJOR) {
			gint _tmp56_;
			_tmp56_ = minor;
			_tmp54_ = _tmp56_ == DUPLICITY_PLUGIN_REQUIRED_MINOR;
		} else {
			_tmp54_ = FALSE;
		}
		_tmp57_ = _tmp54_;
		if (_tmp57_) {
			gint _tmp58_;
			_tmp58_ = micro;
			_tmp53_ = _tmp58_ >= DUPLICITY_PLUGIN_REQUIRED_MICRO;
		} else {
			_tmp53_ = FALSE;
		}
		_tmp59_ = _tmp53_;
		_tmp45_ = _tmp59_;
	}
	_tmp60_ = _tmp45_;
	meets = _tmp60_;
	_tmp61_ = meets;
	if (!_tmp61_) {
		const gchar* _tmp62_ = NULL;
		gint _tmp63_;
		gint _tmp64_;
		gint _tmp65_;
		gchar* _tmp66_ = NULL;
		gchar* _tmp67_;
		GError* _tmp68_;
		GError* _tmp69_;
		_tmp62_ = _ ("Déjà Dup Backup Tool requires at least version %d.%d.%.2d of duplicity" \
", but only found version %d.%d.%.2d");
		_tmp63_ = major;
		_tmp64_ = minor;
		_tmp65_ = micro;
		_tmp66_ = g_strdup_printf (_tmp62_, DUPLICITY_PLUGIN_REQUIRED_MAJOR, DUPLICITY_PLUGIN_REQUIRED_MINOR, DUPLICITY_PLUGIN_REQUIRED_MICRO, _tmp63_, _tmp64_, _tmp65_);
		_tmp67_ = _tmp66_;
		_tmp68_ = g_error_new_literal (G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED, _tmp67_);
		_tmp69_ = _tmp68_;
		_g_free0 (_tmp67_);
		_inner_error_ = _tmp69_;
		g_propagate_error (error, _inner_error_);
		ver_tokens = (_vala_array_free (ver_tokens, ver_tokens_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (version_string);
		tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (output);
		return;
	}
	ver_tokens = (_vala_array_free (ver_tokens, ver_tokens_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (version_string);
	tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (output);
}


static DejaDupToolJob* duplicity_plugin_real_create_job (DejaDupToolPlugin* base, GError** error) {
	DuplicityPlugin * self;
	DejaDupToolJob* result = NULL;
	gboolean _tmp0_;
	DuplicityJob* _tmp1_;
	GError * _inner_error_ = NULL;
	self = (DuplicityPlugin*) base;
	_tmp0_ = self->priv->has_been_setup;
	if (!_tmp0_) {
		duplicity_plugin_do_initial_setup (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		}
		self->priv->has_been_setup = TRUE;
	}
	_tmp1_ = duplicity_job_new ();
	result = (DejaDupToolJob*) _tmp1_;
	return result;
}


DuplicityPlugin* duplicity_plugin_construct (GType object_type) {
	DuplicityPlugin * self = NULL;
	self = (DuplicityPlugin*) deja_dup_tool_plugin_construct (object_type);
	return self;
}


DuplicityPlugin* duplicity_plugin_new (void) {
	return duplicity_plugin_construct (TYPE_DUPLICITY_PLUGIN);
}


static GObject * duplicity_plugin_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	DuplicityPlugin * self;
	parent_class = G_OBJECT_CLASS (duplicity_plugin_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = DUPLICITY_PLUGIN (obj);
	deja_dup_tool_plugin_set_name ((DejaDupToolPlugin*) self, "Duplicity");
	return obj;
}


static void duplicity_plugin_class_init (DuplicityPluginClass * klass) {
	duplicity_plugin_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (DuplicityPluginPrivate));
	DEJA_DUP_TOOL_PLUGIN_CLASS (klass)->create_job = duplicity_plugin_real_create_job;
	G_OBJECT_CLASS (klass)->constructor = duplicity_plugin_constructor;
	G_OBJECT_CLASS (klass)->finalize = duplicity_plugin_finalize;
}


static void duplicity_plugin_instance_init (DuplicityPlugin * self) {
	self->priv = DUPLICITY_PLUGIN_GET_PRIVATE (self);
	self->priv->has_been_setup = FALSE;
}


static void duplicity_plugin_finalize (GObject* obj) {
	DuplicityPlugin * self;
	self = DUPLICITY_PLUGIN (obj);
	G_OBJECT_CLASS (duplicity_plugin_parent_class)->finalize (obj);
}


GType duplicity_plugin_get_type (void) {
	return duplicity_plugin_type_id;
}


GType duplicity_plugin_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (DuplicityPluginClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) duplicity_plugin_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (DuplicityPlugin), 0, (GInstanceInitFunc) duplicity_plugin_instance_init, NULL };
	duplicity_plugin_type_id = g_type_module_register_type (module, DEJA_DUP_TYPE_TOOL_PLUGIN, "DuplicityPlugin", &g_define_type_info, 0);
	return duplicity_plugin_type_id;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void peas_register_types (GTypeModule* module) {
	GTypeModule* _tmp0_;
	PeasObjectModule* _tmp1_;
	PeasObjectModule* objmodule;
	g_return_if_fail (module != NULL);
	duplicity_instance_register_type (module);
	duplicity_job_register_type (module);
	duplicity_plugin_register_type (module);
	_tmp0_ = module;
	_tmp1_ = _g_object_ref0 (PEAS_IS_OBJECT_MODULE (_tmp0_) ? ((PeasObjectModule*) _tmp0_) : NULL);
	objmodule = _tmp1_;
	peas_object_module_register_extension_type (objmodule, peas_activatable_get_type (), TYPE_DUPLICITY_PLUGIN);
	_g_object_unref0 (objmodule);
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



