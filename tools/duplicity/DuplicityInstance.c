/* DuplicityInstance.c generated by valac 0.16.1, the Vala compiler
 * generated from DuplicityInstance.vala, do not modify */

/* -*- Mode: Vala; indent-tabs-mode: nil; tab-width: 2 -*- */
/*
    This file is part of Déjà Dup.
    For copyright information, see AUTHORS.

    Déjà Dup is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Déjà Dup is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Déjà Dup.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <common.h>
#include <config.h>
#include <glib/gstdio.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <gio/gunixinputstream.h>
#include <sys/wait.h>


#define TYPE_DUPLICITY_INSTANCE (duplicity_instance_get_type ())
#define DUPLICITY_INSTANCE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DUPLICITY_INSTANCE, DuplicityInstance))
#define DUPLICITY_INSTANCE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DUPLICITY_INSTANCE, DuplicityInstanceClass))
#define IS_DUPLICITY_INSTANCE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DUPLICITY_INSTANCE))
#define IS_DUPLICITY_INSTANCE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DUPLICITY_INSTANCE))
#define DUPLICITY_INSTANCE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DUPLICITY_INSTANCE, DuplicityInstanceClass))

typedef struct _DuplicityInstance DuplicityInstance;
typedef struct _DuplicityInstanceClass DuplicityInstanceClass;
typedef struct _DuplicityInstancePrivate DuplicityInstancePrivate;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define __g_list_free__g_free0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_free0_ (var), NULL)))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))
typedef struct _DuplicityInstanceReadLogLinesData DuplicityInstanceReadLogLinesData;
typedef struct _DuplicityInstanceReadLogData DuplicityInstanceReadLogData;

struct _DuplicityInstance {
	GObject parent_instance;
	DuplicityInstancePrivate * priv;
};

struct _DuplicityInstanceClass {
	GObjectClass parent_class;
	void (*start) (DuplicityInstance* self, GList* argv_in, GList* envp_in, gboolean as_root, GError** error);
};

struct _DuplicityInstancePrivate {
	gboolean _verbose;
	gchar* _forced_cache_dir;
	guint watch_id;
	GPid child_pid;
	gint* pipes;
	gint pipes_length1;
	gint _pipes_size_;
	GDataInputStream* reader;
	GFile* logfile;
	GFile* scriptfile;
	gboolean process_done;
	gint status;
	gboolean processed_a_message;
};

struct _DuplicityInstanceReadLogLinesData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	DuplicityInstance* self;
	GList* stanza;
	GDataInputStream* _tmp0_;
	GDataInputStream* _tmp1_;
	gchar* _tmp2_;
	gchar* line;
	const gchar* _tmp3_;
	gboolean _tmp4_;
	const gchar* _tmp5_;
	gboolean _tmp6_;
	const gchar* _tmp7_;
	const gchar* _tmp8_;
	gchar* _tmp9_;
	GList* _tmp10_;
	gboolean _tmp11_;
	GList* _tmp12_;
	GError* err;
	GError* _tmp13_;
	const gchar* _tmp14_;
	GFile* _tmp15_;
	GFile* _tmp16_;
	GError* e2;
	GError* _tmp17_;
	const gchar* _tmp18_;
	GError * _inner_error_;
};

struct _DuplicityInstanceReadLogData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	DuplicityInstance* self;
	GInputStream* stream;
	GFile* _tmp0_;
	GFile* _tmp1_;
	GFileInputStream* _tmp2_;
	GFileInputStream* _tmp3_;
	gint* _tmp4_;
	gint _tmp4__length1;
	gint _tmp5_;
	GUnixInputStream* _tmp6_;
	GInputStream* _tmp7_;
	GDataInputStream* _tmp8_;
	GError* e;
	GError* _tmp9_;
	const gchar* _tmp10_;
	GError * _inner_error_;
};


static gpointer duplicity_instance_parent_class = NULL;
static GType duplicity_instance_type_id = 0;

GType duplicity_instance_get_type (void) G_GNUC_CONST;
GType duplicity_instance_register_type (GTypeModule * module);
#define DUPLICITY_INSTANCE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_DUPLICITY_INSTANCE, DuplicityInstancePrivate))
enum  {
	DUPLICITY_INSTANCE_DUMMY_PROPERTY,
	DUPLICITY_INSTANCE_VERBOSE,
	DUPLICITY_INSTANCE_FORCED_CACHE_DIR
};
gboolean duplicity_instance_is_started (DuplicityInstance* self);
static void duplicity_instance_kill_child (DuplicityInstance* self);
void duplicity_instance_start (DuplicityInstance* self, GList* argv_in, GList* envp_in, gboolean as_root, GError** error);
static void duplicity_instance_real_start (DuplicityInstance* self, GList* argv_in, GList* envp_in, gboolean as_root, GError** error);
static void duplicity_instance_set_verbose (DuplicityInstance* self, gboolean value);
const gchar* duplicity_instance_get_forced_cache_dir (DuplicityInstance* self);
static void _g_free0_ (gpointer var);
static void _g_list_free__g_free0_ (GList* self);
static void __lambda2_ (DuplicityInstance* self);
static void ___lambda2__gspawn_child_setup_func (gpointer self);
static void duplicity_instance_spawn_finished (DuplicityInstance* self, GPid pid, gint status);
static void _duplicity_instance_spawn_finished_gchild_watch_func (GPid pid, gint status, gpointer self);
static void duplicity_instance_read_log (DuplicityInstance* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
static void duplicity_instance_read_log_finish (DuplicityInstance* self, GAsyncResult* _res_);
void duplicity_instance_cancel (DuplicityInstance* self);
void duplicity_instance_pause (DuplicityInstance* self);
static void duplicity_instance_stop_child (DuplicityInstance* self);
void duplicity_instance_resume (DuplicityInstance* self);
static void duplicity_instance_cont_child (DuplicityInstance* self);
static void duplicity_instance_read_log_lines_data_free (gpointer _data);
static void duplicity_instance_read_log_lines (DuplicityInstance* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
static void duplicity_instance_read_log_lines_finish (DuplicityInstance* self, GAsyncResult* _res_);
static gboolean duplicity_instance_read_log_lines_co (DuplicityInstanceReadLogLinesData* _data_);
static void duplicity_instance_read_log_lines_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void duplicity_instance_send_done_for_status (DuplicityInstance* self);
static gboolean ______lambda3_ (DuplicityInstance* self);
static gboolean _______lambda3__gsource_func (gpointer self);
gboolean duplicity_instance_get_verbose (DuplicityInstance* self);
static void duplicity_instance_process_stanza (DuplicityInstance* self, GList* stanza);
static void duplicity_instance_read_log_data_free (gpointer _data);
static gboolean duplicity_instance_read_log_co (DuplicityInstanceReadLogData* _data_);
static void duplicity_instance_read_log_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static gint duplicity_instance_num_suffix (const gchar* word, gchar ch, glong start);
static gchar* duplicity_instance_validated_string (const gchar* s);
static gchar* duplicity_instance_compress_string (const gchar* s_in);
static void duplicity_instance_split_line (const gchar* line, gchar*** split, int* split_length1);
static GList* duplicity_instance_grab_stanza_data (DuplicityInstance* self, GList* stanza);
static gchar* duplicity_instance_grab_stanza_text (DuplicityInstance* self, GList* stanza);
DuplicityInstance* duplicity_instance_new (void);
DuplicityInstance* duplicity_instance_construct (GType object_type);
void duplicity_instance_set_forced_cache_dir (DuplicityInstance* self, const gchar* value);
static void g_cclosure_user_marshal_VOID__BOOLEAN_BOOLEAN (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void g_cclosure_user_marshal_VOID__BOXED_INT_POINTER_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static GObject * duplicity_instance_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void duplicity_instance_finalize (GObject* obj);
static void _vala_duplicity_instance_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_duplicity_instance_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


static void _g_list_free__g_free0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_free0_, NULL);
	g_list_free (self);
}


static void __lambda2_ (DuplicityInstance* self) {
	setsid ();
}


static void ___lambda2__gspawn_child_setup_func (gpointer self) {
	__lambda2_ (self);
}


static void _duplicity_instance_spawn_finished_gchild_watch_func (GPid pid, gint status, gpointer self) {
	duplicity_instance_spawn_finished (self, pid, status);
}


static void duplicity_instance_real_start (DuplicityInstance* self, GList* argv_in, GList* envp_in, gboolean as_root, GError** error) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gchar* verbose_str;
	gboolean _tmp2_ = FALSE;
	const gchar* _tmp3_;
	gboolean _tmp6_;
	gboolean _tmp7_;
	gboolean _tmp11_ = FALSE;
	gboolean _tmp12_;
	gboolean _tmp14_;
	gchar** _tmp15_;
	gchar** _tmp16_ = NULL;
	gchar** myenv;
	gint myenv_length1;
	gint _myenv_size_;
	gint myenv_len;
	gint _tmp21_;
	GList* _tmp22_;
	guint _tmp23_ = 0U;
	guint env_len;
	guint _tmp24_;
	gchar** _tmp25_ = NULL;
	gchar** real_envp;
	gint real_envp_length1;
	gint _real_envp_size_;
	gint i;
	GList* _tmp42_;
	gchar** _tmp49_;
	gint _tmp49__length1;
	gint _tmp50_;
	gchar* _tmp51_;
	GList* argv;
	GList* _tmp52_;
	gchar* _tmp56_;
	gchar* _tmp57_;
	const gchar* _tmp58_;
	gchar* _tmp59_;
	gchar* cache_dir;
	const gchar* _tmp60_;
	const gchar* _tmp63_;
	gboolean _tmp78_;
	gchar* _tmp95_;
	gchar* user_cmd;
	GList* _tmp96_;
	gboolean _tmp107_ = FALSE;
	gboolean _tmp108_ = FALSE;
	gboolean _tmp109_;
	gboolean _tmp112_;
	gboolean _tmp115_;
	GList* _tmp150_;
	guint _tmp151_ = 0U;
	gchar** _tmp152_ = NULL;
	gchar** real_argv;
	gint real_argv_length1;
	gint _real_argv_size_;
	GList* _tmp153_;
	gchar** _tmp160_;
	gint _tmp160__length1;
	gchar** _tmp161_;
	gint _tmp161__length1;
	GPid _tmp162_ = 0;
	GPid _tmp163_;
	const gchar* _tmp164_;
	GPid _tmp165_;
	guint _tmp166_ = 0U;
	gint* _tmp167_;
	gint _tmp167__length1;
	gint _tmp168_;
	GError * _inner_error_ = NULL;
	_tmp0_ = g_getenv ("DEJA_DUP_DEBUG");
	_tmp1_ = g_strdup (_tmp0_);
	verbose_str = _tmp1_;
	_tmp3_ = verbose_str;
	if (_tmp3_ != NULL) {
		const gchar* _tmp4_;
		gint _tmp5_ = 0;
		_tmp4_ = verbose_str;
		_tmp5_ = atoi (_tmp4_);
		_tmp2_ = _tmp5_ > 0;
	} else {
		_tmp2_ = FALSE;
	}
	_tmp6_ = _tmp2_;
	if (_tmp6_) {
		duplicity_instance_set_verbose (self, TRUE);
	}
	_tmp7_ = as_root;
	if (_tmp7_) {
		DejaDupSimpleSettings* _tmp8_ = NULL;
		DejaDupSimpleSettings* settings;
		DejaDupSimpleSettings* _tmp9_;
		gboolean _tmp10_ = FALSE;
		_tmp8_ = deja_dup_get_settings (NULL);
		settings = _tmp8_;
		_tmp9_ = settings;
		_tmp10_ = g_settings_get_boolean ((GSettings*) _tmp9_, DEJA_DUP_ROOT_PROMPT_KEY);
		if (!_tmp10_) {
			as_root = FALSE;
		}
		_g_object_unref0 (settings);
	}
	_tmp12_ = as_root;
	if (_tmp12_) {
		const gchar* _tmp13_ = NULL;
		_tmp13_ = g_getenv ("DEJA_DUP_TESTING");
		_tmp11_ = _tmp13_ != NULL;
	} else {
		_tmp11_ = FALSE;
	}
	_tmp14_ = _tmp11_;
	if (_tmp14_) {
		as_root = FALSE;
	}
	_tmp16_ = _tmp15_ = g_listenv ();
	myenv = _tmp16_;
	myenv_length1 = _vala_array_length (_tmp15_);
	_myenv_size_ = myenv_length1;
	myenv_len = 0;
	while (TRUE) {
		gchar** _tmp17_;
		gint _tmp17__length1;
		gint _tmp18_;
		const gchar* _tmp19_;
		gint _tmp20_;
		_tmp17_ = myenv;
		_tmp17__length1 = myenv_length1;
		_tmp18_ = myenv_len;
		_tmp19_ = _tmp17_[_tmp18_];
		if (!(_tmp19_ != NULL)) {
			break;
		}
		_tmp20_ = myenv_len;
		myenv_len = _tmp20_ + 1;
	}
	_tmp21_ = myenv_len;
	_tmp22_ = envp_in;
	_tmp23_ = g_list_length (_tmp22_);
	env_len = _tmp21_ + _tmp23_;
	_tmp24_ = env_len;
	_tmp25_ = g_new0 (gchar*, (_tmp24_ + 1) + 1);
	real_envp = _tmp25_;
	real_envp_length1 = _tmp24_ + 1;
	_real_envp_size_ = real_envp_length1;
	i = 0;
	{
		gboolean _tmp26_;
		_tmp26_ = TRUE;
		while (TRUE) {
			gboolean _tmp27_;
			gint _tmp29_;
			gint _tmp30_;
			gchar** _tmp31_;
			gint _tmp31__length1;
			gint _tmp32_;
			gchar** _tmp33_;
			gint _tmp33__length1;
			gint _tmp34_;
			const gchar* _tmp35_;
			gchar** _tmp36_;
			gint _tmp36__length1;
			gint _tmp37_;
			const gchar* _tmp38_;
			const gchar* _tmp39_ = NULL;
			gchar* _tmp40_ = NULL;
			gchar* _tmp41_;
			_tmp27_ = _tmp26_;
			if (!_tmp27_) {
				gint _tmp28_;
				_tmp28_ = i;
				i = _tmp28_ + 1;
			}
			_tmp26_ = FALSE;
			_tmp29_ = i;
			_tmp30_ = myenv_len;
			if (!(_tmp29_ < _tmp30_)) {
				break;
			}
			_tmp31_ = real_envp;
			_tmp31__length1 = real_envp_length1;
			_tmp32_ = i;
			_tmp33_ = myenv;
			_tmp33__length1 = myenv_length1;
			_tmp34_ = i;
			_tmp35_ = _tmp33_[_tmp34_];
			_tmp36_ = myenv;
			_tmp36__length1 = myenv_length1;
			_tmp37_ = i;
			_tmp38_ = _tmp36_[_tmp37_];
			_tmp39_ = g_getenv (_tmp38_);
			_tmp40_ = g_strdup_printf ("%s=%s", _tmp35_, _tmp39_);
			_g_free0 (_tmp31_[_tmp32_]);
			_tmp31_[_tmp32_] = _tmp40_;
			_tmp41_ = _tmp31_[_tmp32_];
		}
	}
	_tmp42_ = envp_in;
	{
		GList* env_collection = NULL;
		GList* env_it = NULL;
		env_collection = _tmp42_;
		for (env_it = env_collection; env_it != NULL; env_it = env_it->next) {
			gchar* _tmp43_;
			gchar* env = NULL;
			_tmp43_ = g_strdup ((const gchar*) env_it->data);
			env = _tmp43_;
			{
				gchar** _tmp44_;
				gint _tmp44__length1;
				gint _tmp45_;
				const gchar* _tmp46_;
				gchar* _tmp47_;
				gchar* _tmp48_;
				_tmp44_ = real_envp;
				_tmp44__length1 = real_envp_length1;
				_tmp45_ = i;
				i = _tmp45_ + 1;
				_tmp46_ = env;
				_tmp47_ = g_strdup (_tmp46_);
				_g_free0 (_tmp44_[_tmp45_]);
				_tmp44_[_tmp45_] = _tmp47_;
				_tmp48_ = _tmp44_[_tmp45_];
				_g_free0 (env);
			}
		}
	}
	_tmp49_ = real_envp;
	_tmp49__length1 = real_envp_length1;
	_tmp50_ = i;
	_g_free0 (_tmp49_[_tmp50_]);
	_tmp49_[_tmp50_] = NULL;
	_tmp51_ = _tmp49_[_tmp50_];
	argv = NULL;
	_tmp52_ = argv_in;
	{
		GList* arg_collection = NULL;
		GList* arg_it = NULL;
		arg_collection = _tmp52_;
		for (arg_it = arg_collection; arg_it != NULL; arg_it = arg_it->next) {
			gchar* _tmp53_;
			gchar* arg = NULL;
			_tmp53_ = g_strdup ((const gchar*) arg_it->data);
			arg = _tmp53_;
			{
				const gchar* _tmp54_;
				gchar* _tmp55_;
				_tmp54_ = arg;
				_tmp55_ = g_strdup (_tmp54_);
				argv = g_list_append (argv, _tmp55_);
				_g_free0 (arg);
			}
		}
	}
	_tmp56_ = g_strdup ("--verbosity=9");
	argv = g_list_append (argv, _tmp56_);
	_tmp57_ = g_strdup ("--gpg-options=--no-use-agent");
	argv = g_list_append (argv, _tmp57_);
	_tmp58_ = self->priv->_forced_cache_dir;
	_tmp59_ = g_strdup (_tmp58_);
	cache_dir = _tmp59_;
	_tmp60_ = cache_dir;
	if (_tmp60_ == NULL) {
		const gchar* _tmp61_ = NULL;
		gchar* _tmp62_;
		_tmp61_ = g_get_user_cache_dir ();
		_tmp62_ = g_strdup (_tmp61_);
		_g_free0 (cache_dir);
		cache_dir = _tmp62_;
	}
	_tmp63_ = cache_dir;
	if (_tmp63_ != NULL) {
		gboolean add_dir;
		const gchar* _tmp64_;
		GFile* _tmp65_ = NULL;
		GFile* cache_file;
		GFile* _tmp66_;
		GFile* _tmp67_ = NULL;
		gboolean _tmp73_;
		add_dir = FALSE;
		_tmp64_ = cache_dir;
		_tmp65_ = g_file_new_for_path (_tmp64_);
		cache_file = _tmp65_;
		_tmp66_ = cache_file;
		_tmp67_ = g_file_get_child (_tmp66_, PACKAGE);
		_g_object_unref0 (cache_file);
		cache_file = _tmp67_;
		{
			GFile* _tmp68_;
			gboolean _tmp69_ = FALSE;
			gboolean _tmp70_;
			_tmp68_ = cache_file;
			_tmp69_ = g_file_make_directory_with_parents (_tmp68_, NULL, &_inner_error_);
			_tmp70_ = _tmp69_;
			if (_inner_error_ != NULL) {
				if (g_error_matches (_inner_error_, G_IO_ERROR, G_IO_ERROR_EXISTS)) {
					goto __catch1_g_io_error_exists;
				}
				goto __catch1_g_error;
			}
			if (_tmp70_) {
				add_dir = TRUE;
			}
		}
		goto __finally1;
		__catch1_g_io_error_exists:
		{
			GError* e = NULL;
			e = _inner_error_;
			_inner_error_ = NULL;
			add_dir = TRUE;
			_g_error_free0 (e);
		}
		goto __finally1;
		__catch1_g_error:
		{
			GError* e = NULL;
			GError* _tmp71_;
			const gchar* _tmp72_;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp71_ = e;
			_tmp72_ = _tmp71_->message;
			g_warning ("DuplicityInstance.vala:90: %s\n", _tmp72_);
			_g_error_free0 (e);
		}
		__finally1:
		if (_inner_error_ != NULL) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (cache_file);
			_g_free0 (cache_dir);
			__g_list_free__g_free0_0 (argv);
			real_envp = (_vala_array_free (real_envp, real_envp_length1, (GDestroyNotify) g_free), NULL);
			myenv = (_vala_array_free (myenv, myenv_length1, (GDestroyNotify) g_free), NULL);
			_g_free0 (verbose_str);
			return;
		}
		_tmp73_ = add_dir;
		if (_tmp73_) {
			GFile* _tmp74_;
			gchar* _tmp75_ = NULL;
			gchar* _tmp76_;
			gchar* _tmp77_;
			_tmp74_ = cache_file;
			_tmp75_ = g_file_get_path (_tmp74_);
			_tmp76_ = _tmp75_;
			_tmp77_ = g_strconcat ("--archive-dir=", _tmp76_, NULL);
			argv = g_list_append (argv, _tmp77_);
			_g_free0 (_tmp76_);
		}
		_g_object_unref0 (cache_file);
	}
	_tmp78_ = as_root;
	if (_tmp78_) {
		gint logfd;
		GFile* _tmp86_;
		gchar* _tmp87_ = NULL;
		gchar* _tmp88_;
		gchar* _tmp89_ = NULL;
		logfd = 0;
		{
			gchar* logname = NULL;
			gchar* _tmp79_ = NULL;
			gint _tmp80_ = 0;
			gint _tmp81_;
			const gchar* _tmp82_;
			GFile* _tmp83_ = NULL;
			_tmp80_ = g_file_open_tmp (PACKAGE "-XXXXXX", &_tmp79_, &_inner_error_);
			_g_free0 (logname);
			logname = _tmp79_;
			_tmp81_ = _tmp80_;
			if (_inner_error_ != NULL) {
				_g_free0 (logname);
				goto __catch2_g_error;
			}
			logfd = _tmp81_;
			_tmp82_ = logname;
			_tmp83_ = g_file_new_for_path (_tmp82_);
			_g_object_unref0 (self->priv->logfile);
			self->priv->logfile = _tmp83_;
			_g_free0 (logname);
		}
		goto __finally2;
		__catch2_g_error:
		{
			GError* e = NULL;
			GError* _tmp84_;
			const gchar* _tmp85_;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp84_ = e;
			_tmp85_ = _tmp84_->message;
			g_warning ("DuplicityInstance.vala:106: %s\n", _tmp85_);
			g_signal_emit_by_name (self, "done", FALSE, FALSE);
			_g_error_free0 (e);
			_g_free0 (cache_dir);
			__g_list_free__g_free0_0 (argv);
			real_envp = (_vala_array_free (real_envp, real_envp_length1, (GDestroyNotify) g_free), NULL);
			myenv = (_vala_array_free (myenv, myenv_length1, (GDestroyNotify) g_free), NULL);
			_g_free0 (verbose_str);
			return;
		}
		__finally2:
		if (_inner_error_ != NULL) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (cache_dir);
			__g_list_free__g_free0_0 (argv);
			real_envp = (_vala_array_free (real_envp, real_envp_length1, (GDestroyNotify) g_free), NULL);
			myenv = (_vala_array_free (myenv, myenv_length1, (GDestroyNotify) g_free), NULL);
			_g_free0 (verbose_str);
			return;
		}
		_tmp86_ = self->priv->logfile;
		_tmp87_ = g_file_get_path (_tmp86_);
		_tmp88_ = _tmp87_;
		_tmp89_ = g_strdup_printf ("--log-file=%s", _tmp88_);
		argv = g_list_append (argv, _tmp89_);
		_g_free0 (_tmp88_);
	} else {
		gint* _tmp90_;
		gint _tmp90__length1;
		gint _tmp91_ = 0;
		gint* _tmp92_;
		gint _tmp92__length1;
		gint _tmp93_;
		gchar* _tmp94_ = NULL;
		_tmp90_ = self->priv->pipes;
		_tmp90__length1 = self->priv->pipes_length1;
		_tmp91_ = pipe (_tmp90_);
		if (_tmp91_ != 0) {
			g_signal_emit_by_name (self, "done", FALSE, FALSE);
			_g_free0 (cache_dir);
			__g_list_free__g_free0_0 (argv);
			real_envp = (_vala_array_free (real_envp, real_envp_length1, (GDestroyNotify) g_free), NULL);
			myenv = (_vala_array_free (myenv, myenv_length1, (GDestroyNotify) g_free), NULL);
			_g_free0 (verbose_str);
			return;
		}
		_tmp92_ = self->priv->pipes;
		_tmp92__length1 = self->priv->pipes_length1;
		_tmp93_ = _tmp92_[1];
		_tmp94_ = g_strdup_printf ("--log-fd=%d", _tmp93_);
		argv = g_list_append (argv, _tmp94_);
	}
	_tmp95_ = g_strdup ("duplicity");
	argv = g_list_prepend (argv, _tmp95_);
	user_cmd = NULL;
	_tmp96_ = argv;
	{
		GList* a_collection = NULL;
		GList* a_it = NULL;
		a_collection = _tmp96_;
		for (a_it = a_collection; a_it != NULL; a_it = a_it->next) {
			gchar* _tmp97_;
			gchar* a = NULL;
			_tmp97_ = g_strdup ((const gchar*) a_it->data);
			a = _tmp97_;
			{
				const gchar* _tmp98_;
				const gchar* _tmp99_;
				_tmp98_ = a;
				if (_tmp98_ == NULL) {
					_g_free0 (a);
					break;
				}
				_tmp99_ = user_cmd;
				if (_tmp99_ == NULL) {
					const gchar* _tmp100_;
					gchar* _tmp101_;
					_tmp100_ = a;
					_tmp101_ = g_strdup (_tmp100_);
					_g_free0 (user_cmd);
					user_cmd = _tmp101_;
				} else {
					const gchar* _tmp102_;
					const gchar* _tmp103_;
					gchar* _tmp104_ = NULL;
					gchar* _tmp105_;
					gchar* _tmp106_ = NULL;
					_tmp102_ = user_cmd;
					_tmp103_ = a;
					_tmp104_ = g_shell_quote (_tmp103_);
					_tmp105_ = _tmp104_;
					_tmp106_ = g_strdup_printf ("%s %s", _tmp102_, _tmp105_);
					_g_free0 (user_cmd);
					user_cmd = _tmp106_;
					_g_free0 (_tmp105_);
				}
				_g_free0 (a);
			}
		}
	}
	_tmp109_ = as_root;
	if (_tmp109_) {
		gchar* _tmp110_ = NULL;
		gchar* _tmp111_;
		_tmp110_ = g_find_program_in_path ("pkexec");
		_tmp111_ = _tmp110_;
		_tmp108_ = _tmp111_ != NULL;
		_g_free0 (_tmp111_);
	} else {
		_tmp108_ = FALSE;
	}
	_tmp112_ = _tmp108_;
	if (_tmp112_) {
		gchar* _tmp113_ = NULL;
		gchar* _tmp114_;
		_tmp113_ = g_find_program_in_path ("sh");
		_tmp114_ = _tmp113_;
		_tmp107_ = _tmp114_ != NULL;
		_g_free0 (_tmp114_);
	} else {
		_tmp107_ = FALSE;
	}
	_tmp115_ = _tmp107_;
	if (_tmp115_) {
		gchar* scriptname = NULL;
		gchar* _tmp116_ = NULL;
		gint _tmp117_ = 0;
		gint scriptfd;
		const gchar* _tmp118_;
		GFile* _tmp119_ = NULL;
		gint _tmp120_;
		GString* _tmp121_;
		GString* args;
		GList* _tmp122_;
		GList* _tmp128_;
		const gchar* _tmp143_;
		GString* _tmp144_;
		const gchar* _tmp145_;
		const gchar* _tmp146_;
		gchar* _tmp147_;
		gchar* _tmp148_;
		gchar* _tmp149_;
		_tmp117_ = g_file_open_tmp (PACKAGE "-XXXXXX", &_tmp116_, &_inner_error_);
		_g_free0 (scriptname);
		scriptname = _tmp116_;
		scriptfd = _tmp117_;
		if (_inner_error_ != NULL) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (scriptname);
			_g_free0 (user_cmd);
			_g_free0 (cache_dir);
			__g_list_free__g_free0_0 (argv);
			real_envp = (_vala_array_free (real_envp, real_envp_length1, (GDestroyNotify) g_free), NULL);
			myenv = (_vala_array_free (myenv, myenv_length1, (GDestroyNotify) g_free), NULL);
			_g_free0 (verbose_str);
			return;
		}
		_tmp118_ = scriptname;
		_tmp119_ = g_file_new_for_path (_tmp118_);
		_g_object_unref0 (self->priv->scriptfile);
		self->priv->scriptfile = _tmp119_;
		_tmp120_ = scriptfd;
		close (_tmp120_);
		_tmp121_ = g_string_new ("");
		args = _tmp121_;
		_tmp122_ = envp_in;
		{
			GList* env_collection = NULL;
			GList* env_it = NULL;
			env_collection = _tmp122_;
			for (env_it = env_collection; env_it != NULL; env_it = env_it->next) {
				gchar* _tmp123_;
				gchar* env = NULL;
				_tmp123_ = g_strdup ((const gchar*) env_it->data);
				env = _tmp123_;
				{
					GString* _tmp124_;
					const gchar* _tmp125_;
					gchar* _tmp126_ = NULL;
					gchar* _tmp127_;
					_tmp124_ = args;
					_tmp125_ = env;
					_tmp126_ = g_strdup_printf ("export '%s'\n", _tmp125_);
					_tmp127_ = _tmp126_;
					g_string_append (_tmp124_, _tmp127_);
					_g_free0 (_tmp127_);
					_g_free0 (env);
				}
			}
		}
		_tmp128_ = argv;
		{
			GList* a_collection = NULL;
			GList* a_it = NULL;
			a_collection = _tmp128_;
			for (a_it = a_collection; a_it != NULL; a_it = a_it->next) {
				gchar* _tmp129_;
				gchar* a = NULL;
				_tmp129_ = g_strdup ((const gchar*) a_it->data);
				a = _tmp129_;
				{
					const gchar* _tmp130_;
					GString* _tmp131_;
					gssize _tmp132_;
					_tmp130_ = a;
					if (_tmp130_ == NULL) {
						_g_free0 (a);
						break;
					}
					_tmp131_ = args;
					_tmp132_ = _tmp131_->len;
					if (_tmp132_ == ((gssize) 0)) {
						GString* _tmp133_;
						const gchar* _tmp134_;
						gchar* _tmp135_ = NULL;
						gchar* _tmp136_;
						_tmp133_ = args;
						_tmp134_ = a;
						_tmp135_ = g_shell_quote (_tmp134_);
						_tmp136_ = _tmp135_;
						g_string_append (_tmp133_, _tmp136_);
						_g_free0 (_tmp136_);
					} else {
						GString* _tmp137_;
						const gchar* _tmp138_;
						gchar* _tmp139_ = NULL;
						gchar* _tmp140_;
						gchar* _tmp141_;
						gchar* _tmp142_;
						_tmp137_ = args;
						_tmp138_ = a;
						_tmp139_ = g_shell_quote (_tmp138_);
						_tmp140_ = _tmp139_;
						_tmp141_ = g_strconcat (" ", _tmp140_, NULL);
						_tmp142_ = _tmp141_;
						g_string_append (_tmp137_, _tmp142_);
						_g_free0 (_tmp142_);
						_g_free0 (_tmp140_);
					}
					_g_free0 (a);
				}
			}
		}
		_tmp143_ = scriptname;
		_tmp144_ = args;
		_tmp145_ = _tmp144_->str;
		g_file_set_contents (_tmp143_, _tmp145_, (gssize) (-1), &_inner_error_);
		if (_inner_error_ != NULL) {
			g_propagate_error (error, _inner_error_);
			_g_string_free0 (args);
			_g_free0 (scriptname);
			_g_free0 (user_cmd);
			_g_free0 (cache_dir);
			__g_list_free__g_free0_0 (argv);
			real_envp = (_vala_array_free (real_envp, real_envp_length1, (GDestroyNotify) g_free), NULL);
			myenv = (_vala_array_free (myenv, myenv_length1, (GDestroyNotify) g_free), NULL);
			_g_free0 (verbose_str);
			return;
		}
		__g_list_free__g_free0_0 (argv);
		argv = NULL;
		_tmp146_ = scriptname;
		_tmp147_ = g_strdup (_tmp146_);
		argv = g_list_prepend (argv, _tmp147_);
		_tmp148_ = g_strdup ("sh");
		argv = g_list_prepend (argv, _tmp148_);
		_tmp149_ = g_strdup ("pkexec");
		argv = g_list_prepend (argv, _tmp149_);
		_g_string_free0 (args);
		_g_free0 (scriptname);
	}
	_tmp150_ = argv;
	_tmp151_ = g_list_length (_tmp150_);
	_tmp152_ = g_new0 (gchar*, _tmp151_ + 1);
	real_argv = _tmp152_;
	real_argv_length1 = _tmp151_;
	_real_argv_size_ = real_argv_length1;
	i = 0;
	_tmp153_ = argv;
	{
		GList* a_collection = NULL;
		GList* a_it = NULL;
		a_collection = _tmp153_;
		for (a_it = a_collection; a_it != NULL; a_it = a_it->next) {
			gchar* _tmp154_;
			gchar* a = NULL;
			_tmp154_ = g_strdup ((const gchar*) a_it->data);
			a = _tmp154_;
			{
				gchar** _tmp155_;
				gint _tmp155__length1;
				gint _tmp156_;
				const gchar* _tmp157_;
				gchar* _tmp158_;
				gchar* _tmp159_;
				_tmp155_ = real_argv;
				_tmp155__length1 = real_argv_length1;
				_tmp156_ = i;
				i = _tmp156_ + 1;
				_tmp157_ = a;
				_tmp158_ = g_strdup (_tmp157_);
				_g_free0 (_tmp155_[_tmp156_]);
				_tmp155_[_tmp156_] = _tmp158_;
				_tmp159_ = _tmp155_[_tmp156_];
				_g_free0 (a);
			}
		}
	}
	_tmp160_ = real_argv;
	_tmp160__length1 = real_argv_length1;
	_tmp161_ = real_envp;
	_tmp161__length1 = real_envp_length1;
	g_spawn_async_with_pipes (NULL, _tmp160_, _tmp161_, (((G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD) | G_SPAWN_LEAVE_DESCRIPTORS_OPEN) | G_SPAWN_STDOUT_TO_DEV_NULL) | G_SPAWN_STDERR_TO_DEV_NULL, ___lambda2__gspawn_child_setup_func, self, &_tmp162_, NULL, NULL, NULL, &_inner_error_);
	self->priv->child_pid = _tmp162_;
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		real_argv = (_vala_array_free (real_argv, real_argv_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (user_cmd);
		_g_free0 (cache_dir);
		__g_list_free__g_free0_0 (argv);
		real_envp = (_vala_array_free (real_envp, real_envp_length1, (GDestroyNotify) g_free), NULL);
		myenv = (_vala_array_free (myenv, myenv_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (verbose_str);
		return;
	}
	_tmp163_ = self->priv->child_pid;
	_tmp164_ = user_cmd;
	g_debug ("DuplicityInstance.vala:191: Running the following duplicity (%i) comma" \
"nd: %s\n", (gint) _tmp163_, _tmp164_);
	_tmp165_ = self->priv->child_pid;
	_tmp166_ = g_child_watch_add_full (G_PRIORITY_DEFAULT_IDLE, _tmp165_, _duplicity_instance_spawn_finished_gchild_watch_func, g_object_ref (self), g_object_unref);
	self->priv->watch_id = _tmp166_;
	_tmp167_ = self->priv->pipes;
	_tmp167__length1 = self->priv->pipes_length1;
	_tmp168_ = _tmp167_[1];
	if (_tmp168_ != (-1)) {
		gint* _tmp169_;
		gint _tmp169__length1;
		gint _tmp170_;
		_tmp169_ = self->priv->pipes;
		_tmp169__length1 = self->priv->pipes_length1;
		_tmp170_ = _tmp169_[1];
		close (_tmp170_);
	}
	duplicity_instance_read_log (self, NULL, NULL);
	real_argv = (_vala_array_free (real_argv, real_argv_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (user_cmd);
	_g_free0 (cache_dir);
	__g_list_free__g_free0_0 (argv);
	real_envp = (_vala_array_free (real_envp, real_envp_length1, (GDestroyNotify) g_free), NULL);
	myenv = (_vala_array_free (myenv, myenv_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (verbose_str);
}


void duplicity_instance_start (DuplicityInstance* self, GList* argv_in, GList* envp_in, gboolean as_root, GError** error) {
	g_return_if_fail (self != NULL);
	DUPLICITY_INSTANCE_GET_CLASS (self)->start (self, argv_in, envp_in, as_root, error);
}


gboolean duplicity_instance_is_started (DuplicityInstance* self) {
	gboolean result = FALSE;
	GPid _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->child_pid;
	result = ((gint) _tmp0_) > 0;
	return result;
}


void duplicity_instance_cancel (DuplicityInstance* self) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = duplicity_instance_is_started (self);
	if (_tmp0_) {
		duplicity_instance_kill_child (self);
	} else {
		g_signal_emit_by_name (self, "done", FALSE, TRUE);
	}
}


void duplicity_instance_pause (DuplicityInstance* self) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = duplicity_instance_is_started (self);
	if (_tmp0_) {
		duplicity_instance_stop_child (self);
	}
}


void duplicity_instance_resume (DuplicityInstance* self) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = duplicity_instance_is_started (self);
	if (_tmp0_) {
		duplicity_instance_cont_child (self);
	}
}


static void duplicity_instance_kill_child (DuplicityInstance* self) {
	GPid _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->child_pid;
	kill ((pid_t) _tmp0_, SIGKILL);
}


static void duplicity_instance_stop_child (DuplicityInstance* self) {
	GPid _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->child_pid;
	kill ((pid_t) _tmp0_, SIGSTOP);
}


static void duplicity_instance_cont_child (DuplicityInstance* self) {
	GPid _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->child_pid;
	kill ((pid_t) _tmp0_, SIGCONT);
}


static void duplicity_instance_read_log_lines_data_free (gpointer _data) {
	DuplicityInstanceReadLogLinesData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (DuplicityInstanceReadLogLinesData, _data_);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void duplicity_instance_read_log_lines (DuplicityInstance* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	DuplicityInstanceReadLogLinesData* _data_;
	DuplicityInstance* _tmp0_;
	_data_ = g_slice_new0 (DuplicityInstanceReadLogLinesData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, duplicity_instance_read_log_lines);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, duplicity_instance_read_log_lines_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	duplicity_instance_read_log_lines_co (_data_);
}


static void duplicity_instance_read_log_lines_finish (DuplicityInstance* self, GAsyncResult* _res_) {
	DuplicityInstanceReadLogLinesData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void duplicity_instance_read_log_lines_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	DuplicityInstanceReadLogLinesData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	duplicity_instance_read_log_lines_co (_data_);
}


static gboolean ______lambda3_ (DuplicityInstance* self) {
	gboolean result = FALSE;
	duplicity_instance_read_log_lines (self, NULL, NULL);
	result = FALSE;
	return result;
}


static gboolean _______lambda3__gsource_func (gpointer self) {
	gboolean result;
	result = ______lambda3_ (self);
	return result;
}


static gboolean duplicity_instance_read_log_lines_co (DuplicityInstanceReadLogLinesData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->stanza = NULL;
	while (TRUE) {
		_data_->_tmp0_ = _data_->self->priv->reader;
		if (!(_data_->_tmp0_ != NULL)) {
			break;
		}
		{
			_data_->_tmp1_ = _data_->self->priv->reader;
			_data_->_state_ = 1;
			g_data_input_stream_read_line_async (_data_->_tmp1_, G_PRIORITY_DEFAULT, NULL, duplicity_instance_read_log_lines_ready, _data_);
			return FALSE;
			_state_1:
			_data_->_tmp2_ = NULL;
			_data_->_tmp2_ = g_data_input_stream_read_line_finish (_data_->_tmp1_, _data_->_res_, NULL, &_data_->_inner_error_);
			_data_->line = _data_->_tmp2_;
			if (_data_->_inner_error_ != NULL) {
				goto __catch3_g_error;
			}
			_data_->_tmp3_ = _data_->line;
			if (_data_->_tmp3_ == NULL) {
				_data_->_tmp4_ = _data_->self->priv->process_done;
				if (_data_->_tmp4_) {
					duplicity_instance_send_done_for_status (_data_->self);
					_g_free0 (_data_->line);
					break;
				} else {
					g_timeout_add_seconds_full (G_PRIORITY_DEFAULT, (guint) 1, _______lambda3__gsource_func, g_object_ref (_data_->self), g_object_unref);
					_g_free0 (_data_->line);
					__g_list_free__g_free0_0 (_data_->stanza);
					if (_data_->_state_ == 0) {
						g_simple_async_result_complete_in_idle (_data_->_async_result);
					} else {
						g_simple_async_result_complete (_data_->_async_result);
					}
					g_object_unref (_data_->_async_result);
					return FALSE;
				}
			}
			_data_->_tmp5_ = _data_->line;
			if (g_strcmp0 (_data_->_tmp5_, "") != 0) {
				_data_->_tmp6_ = _data_->self->priv->_verbose;
				if (_data_->_tmp6_) {
					_data_->_tmp7_ = _data_->line;
					g_print ("DUPLICITY: %s\n", _data_->_tmp7_);
				}
				_data_->_tmp8_ = _data_->line;
				_data_->_tmp9_ = g_strdup (_data_->_tmp8_);
				_data_->stanza = g_list_append (_data_->stanza, _data_->_tmp9_);
			} else {
				_data_->_tmp10_ = _data_->stanza;
				if (_data_->_tmp10_ != NULL) {
					_data_->_tmp11_ = _data_->self->priv->_verbose;
					if (_data_->_tmp11_) {
						g_print ("\n");
					}
					_data_->_tmp12_ = _data_->stanza;
					duplicity_instance_process_stanza (_data_->self, _data_->_tmp12_);
					__g_list_free__g_free0_0 (_data_->stanza);
					_data_->stanza = NULL;
				}
			}
			_g_free0 (_data_->line);
		}
		goto __finally3;
		__catch3_g_error:
		{
			_data_->err = _data_->_inner_error_;
			_data_->_inner_error_ = NULL;
			_data_->_tmp13_ = _data_->err;
			_data_->_tmp14_ = _data_->_tmp13_->message;
			g_warning ("DuplicityInstance.vala:307: %s\n", _data_->_tmp14_);
			_g_error_free0 (_data_->err);
			break;
		}
		__finally3:
		if (_data_->_inner_error_ != NULL) {
			__g_list_free__g_free0_0 (_data_->stanza);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	_g_object_unref0 (_data_->self->priv->reader);
	_data_->self->priv->reader = NULL;
	_data_->_tmp15_ = _data_->self->priv->logfile;
	if (_data_->_tmp15_ != NULL) {
		{
			_data_->_tmp16_ = _data_->self->priv->logfile;
			g_file_delete (_data_->_tmp16_, NULL, &_data_->_inner_error_);
			if (_data_->_inner_error_ != NULL) {
				goto __catch4_g_error;
			}
		}
		goto __finally4;
		__catch4_g_error:
		{
			_data_->e2 = _data_->_inner_error_;
			_data_->_inner_error_ = NULL;
			_data_->_tmp17_ = _data_->e2;
			_data_->_tmp18_ = _data_->_tmp17_->message;
			g_warning ("DuplicityInstance.vala:317: %s\n", _data_->_tmp18_);
			_g_error_free0 (_data_->e2);
		}
		__finally4:
		if (_data_->_inner_error_ != NULL) {
			__g_list_free__g_free0_0 (_data_->stanza);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	g_object_unref ((GObject*) _data_->self);
	__g_list_free__g_free0_0 (_data_->stanza);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void duplicity_instance_read_log_data_free (gpointer _data) {
	DuplicityInstanceReadLogData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (DuplicityInstanceReadLogData, _data_);
}


static void duplicity_instance_read_log (DuplicityInstance* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	DuplicityInstanceReadLogData* _data_;
	DuplicityInstance* _tmp0_;
	_data_ = g_slice_new0 (DuplicityInstanceReadLogData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, duplicity_instance_read_log);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, duplicity_instance_read_log_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	duplicity_instance_read_log_co (_data_);
}


static void duplicity_instance_read_log_finish (DuplicityInstance* self, GAsyncResult* _res_) {
	DuplicityInstanceReadLogData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void duplicity_instance_read_log_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	DuplicityInstanceReadLogData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	duplicity_instance_read_log_co (_data_);
}


static gboolean duplicity_instance_read_log_co (DuplicityInstanceReadLogData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	{
		_data_->_tmp0_ = _data_->self->priv->logfile;
		if (_data_->_tmp0_ != NULL) {
			_data_->_tmp1_ = _data_->self->priv->logfile;
			_data_->_state_ = 1;
			g_file_read_async (_data_->_tmp1_, G_PRIORITY_DEFAULT, NULL, duplicity_instance_read_log_ready, _data_);
			return FALSE;
			_state_1:
			_data_->_tmp2_ = NULL;
			_data_->_tmp2_ = g_file_read_finish (_data_->_tmp1_, _data_->_res_, &_data_->_inner_error_);
			_data_->_tmp3_ = _data_->_tmp2_;
			if (_data_->_inner_error_ != NULL) {
				_g_object_unref0 (_data_->stream);
				goto __catch5_g_error;
			}
			_g_object_unref0 (_data_->stream);
			_data_->stream = (GInputStream*) _data_->_tmp3_;
		} else {
			_data_->_tmp4_ = _data_->self->priv->pipes;
			_data_->_tmp4__length1 = _data_->self->priv->pipes_length1;
			_data_->_tmp5_ = _data_->_tmp4_[0];
			_data_->_tmp6_ = (GUnixInputStream*) g_unix_input_stream_new (_data_->_tmp5_, TRUE);
			_g_object_unref0 (_data_->stream);
			_data_->stream = (GInputStream*) _data_->_tmp6_;
		}
		_data_->_tmp7_ = _data_->stream;
		_data_->_tmp8_ = g_data_input_stream_new (_data_->_tmp7_);
		_g_object_unref0 (_data_->self->priv->reader);
		_data_->self->priv->reader = _data_->_tmp8_;
		_g_object_unref0 (_data_->stream);
	}
	goto __finally5;
	__catch5_g_error:
	{
		_data_->e = _data_->_inner_error_;
		_data_->_inner_error_ = NULL;
		_data_->_tmp9_ = _data_->e;
		_data_->_tmp10_ = _data_->_tmp9_->message;
		g_warning ("DuplicityInstance.vala:341: %s\n", _data_->_tmp10_);
		g_signal_emit_by_name (_data_->self, "done", FALSE, FALSE);
		_g_error_free0 (_data_->e);
		if (_data_->_state_ == 0) {
			g_simple_async_result_complete_in_idle (_data_->_async_result);
		} else {
			g_simple_async_result_complete (_data_->_async_result);
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	__finally5:
	if (_data_->_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
		g_clear_error (&_data_->_inner_error_);
		return FALSE;
	}
	g_object_ref ((GObject*) _data_->self);
	_data_->_state_ = 2;
	duplicity_instance_read_log_lines (_data_->self, duplicity_instance_read_log_ready, _data_);
	return FALSE;
	_state_2:
	duplicity_instance_read_log_lines_finish (_data_->self, _data_->_res_);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static gchar string_get (const gchar* self, glong index) {
	gchar result = '\0';
	glong _tmp0_;
	gchar _tmp1_;
	g_return_val_if_fail (self != NULL, '\0');
	_tmp0_ = index;
	_tmp1_ = ((gchar*) self)[_tmp0_];
	result = _tmp1_;
	return result;
}


static gint duplicity_instance_num_suffix (const gchar* word, gchar ch, glong start) {
	gint result = 0;
	gint rv;
	glong _tmp0_;
	g_return_val_if_fail (word != NULL, 0);
	rv = 0;
	_tmp0_ = start;
	if (_tmp0_ < ((glong) 0)) {
		const gchar* _tmp1_;
		gint _tmp2_;
		gint _tmp3_;
		_tmp1_ = word;
		_tmp2_ = strlen (_tmp1_);
		_tmp3_ = _tmp2_;
		start = ((glong) _tmp3_) - 1;
	}
	{
		glong _tmp4_;
		glong i;
		_tmp4_ = start;
		i = _tmp4_;
		{
			gboolean _tmp5_;
			_tmp5_ = TRUE;
			while (TRUE) {
				gboolean _tmp6_;
				glong _tmp9_;
				const gchar* _tmp10_;
				glong _tmp11_;
				gchar _tmp12_ = '\0';
				gchar _tmp13_;
				_tmp6_ = _tmp5_;
				if (!_tmp6_) {
					glong _tmp7_;
					gint _tmp8_;
					_tmp7_ = i;
					i = _tmp7_ - 1;
					_tmp8_ = rv;
					rv = _tmp8_ + 1;
				}
				_tmp5_ = FALSE;
				_tmp9_ = i;
				if (!(_tmp9_ >= ((glong) 0))) {
					break;
				}
				_tmp10_ = word;
				_tmp11_ = i;
				_tmp12_ = string_get (_tmp10_, _tmp11_);
				_tmp13_ = ch;
				if (_tmp12_ != _tmp13_) {
					break;
				}
			}
		}
	}
	result = rv;
	return result;
}


static gchar* duplicity_instance_validated_string (const gchar* s) {
	gchar* result = NULL;
	GString* _tmp0_;
	GString* rv;
	const gchar* _tmp1_;
	const gchar* p;
	GString* _tmp16_;
	const gchar* _tmp17_;
	gchar* _tmp18_;
	g_return_val_if_fail (s != NULL, NULL);
	_tmp0_ = g_string_new ("");
	rv = _tmp0_;
	_tmp1_ = s;
	p = _tmp1_;
	while (TRUE) {
		const gchar* _tmp2_;
		gchar _tmp3_ = '\0';
		const gchar* _tmp4_;
		gunichar _tmp5_ = 0U;
		gunichar ch;
		gboolean _tmp6_ = FALSE;
		gunichar _tmp7_;
		gboolean _tmp9_;
		_tmp2_ = p;
		_tmp3_ = string_get (_tmp2_, (glong) 0);
		if (!(((gint) _tmp3_) != 0)) {
			break;
		}
		_tmp4_ = p;
		_tmp5_ = g_utf8_get_char_validated (_tmp4_, (gssize) (-1));
		ch = _tmp5_;
		_tmp7_ = ch;
		if (_tmp7_ == ((gunichar) (-1))) {
			_tmp6_ = TRUE;
		} else {
			gunichar _tmp8_;
			_tmp8_ = ch;
			_tmp6_ = _tmp8_ == ((gunichar) (-2));
		}
		_tmp9_ = _tmp6_;
		if (_tmp9_) {
			GString* _tmp10_;
			const gchar* _tmp11_;
			_tmp10_ = rv;
			g_string_append (_tmp10_, "�");
			_tmp11_ = p;
			p = (const gchar*) (((gchar*) _tmp11_) + 1);
		} else {
			GString* _tmp12_;
			gunichar _tmp13_;
			const gchar* _tmp14_;
			const gchar* _tmp15_ = NULL;
			_tmp12_ = rv;
			_tmp13_ = ch;
			g_string_append_unichar (_tmp12_, _tmp13_);
			_tmp14_ = p;
			_tmp15_ = g_utf8_next_char (_tmp14_);
			p = _tmp15_;
		}
	}
	_tmp16_ = rv;
	_tmp17_ = _tmp16_->str;
	_tmp18_ = g_strdup (_tmp17_);
	result = _tmp18_;
	_g_string_free0 (rv);
	return result;
}


static gchar* duplicity_instance_compress_string (const gchar* s_in) {
	gchar* result = NULL;
	const gchar* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* rv;
	gint rv_length1;
	gint _rv_size_;
	const gchar* _tmp4_;
	gchar* s;
	gint s_length1;
	gint _s_size_;
	gint i;
	gint j;
	gchar* _tmp123_;
	gint _tmp123__length1;
	gchar* _tmp124_;
	g_return_val_if_fail (s_in != NULL, NULL);
	_tmp0_ = s_in;
	_tmp1_ = strlen (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_new0 (gchar, _tmp2_ + 1);
	rv = _tmp3_;
	rv_length1 = _tmp2_ + 1;
	_rv_size_ = rv_length1;
	_tmp4_ = s_in;
	s = (gchar*) _tmp4_;
	s_length1 = -1;
	_s_size_ = s_length1;
	i = 0;
	j = 0;
	while (TRUE) {
		gchar* _tmp5_;
		gint _tmp5__length1;
		gint _tmp6_;
		gchar _tmp7_;
		gboolean _tmp8_ = FALSE;
		gchar* _tmp9_;
		gint _tmp9__length1;
		gint _tmp10_;
		gchar _tmp11_;
		gboolean _tmp15_;
		_tmp5_ = s;
		_tmp5__length1 = s_length1;
		_tmp6_ = i;
		_tmp7_ = _tmp5_[_tmp6_];
		if (!(((gint) _tmp7_) != 0)) {
			break;
		}
		_tmp9_ = s;
		_tmp9__length1 = s_length1;
		_tmp10_ = i;
		_tmp11_ = _tmp9_[_tmp10_];
		if (_tmp11_ == '\\') {
			gchar* _tmp12_;
			gint _tmp12__length1;
			gint _tmp13_;
			gchar _tmp14_;
			_tmp12_ = s;
			_tmp12__length1 = s_length1;
			_tmp13_ = i;
			_tmp14_ = _tmp12_[_tmp13_ + 1];
			_tmp8_ = ((gint) _tmp14_) != 0;
		} else {
			_tmp8_ = FALSE;
		}
		_tmp15_ = _tmp8_;
		if (_tmp15_) {
			gboolean bare_escape;
			gchar* _tmp16_;
			gint _tmp16__length1;
			gint _tmp17_;
			gchar _tmp18_;
			gboolean _tmp109_;
			bare_escape = FALSE;
			_tmp16_ = s;
			_tmp16__length1 = s_length1;
			_tmp17_ = i;
			_tmp18_ = _tmp16_[_tmp17_ + 1];
			switch (_tmp18_) {
				case 'b':
				{
					gchar* _tmp19_;
					gint _tmp19__length1;
					gint _tmp20_;
					gchar _tmp21_;
					gint _tmp22_;
					_tmp19_ = rv;
					_tmp19__length1 = rv_length1;
					_tmp20_ = j;
					j = _tmp20_ + 1;
					_tmp19_[_tmp20_] = '\b';
					_tmp21_ = _tmp19_[_tmp20_];
					_tmp22_ = i;
					i = _tmp22_ + 2;
					break;
				}
				case 'f':
				{
					gchar* _tmp23_;
					gint _tmp23__length1;
					gint _tmp24_;
					gchar _tmp25_;
					gint _tmp26_;
					_tmp23_ = rv;
					_tmp23__length1 = rv_length1;
					_tmp24_ = j;
					j = _tmp24_ + 1;
					_tmp23_[_tmp24_] = '\f';
					_tmp25_ = _tmp23_[_tmp24_];
					_tmp26_ = i;
					i = _tmp26_ + 2;
					break;
				}
				case 't':
				{
					gchar* _tmp27_;
					gint _tmp27__length1;
					gint _tmp28_;
					gchar _tmp29_;
					gint _tmp30_;
					_tmp27_ = rv;
					_tmp27__length1 = rv_length1;
					_tmp28_ = j;
					j = _tmp28_ + 1;
					_tmp27_[_tmp28_] = '\t';
					_tmp29_ = _tmp27_[_tmp28_];
					_tmp30_ = i;
					i = _tmp30_ + 2;
					break;
				}
				case 'n':
				{
					gchar* _tmp31_;
					gint _tmp31__length1;
					gint _tmp32_;
					gchar _tmp33_;
					gint _tmp34_;
					_tmp31_ = rv;
					_tmp31__length1 = rv_length1;
					_tmp32_ = j;
					j = _tmp32_ + 1;
					_tmp31_[_tmp32_] = '\n';
					_tmp33_ = _tmp31_[_tmp32_];
					_tmp34_ = i;
					i = _tmp34_ + 2;
					break;
				}
				case 'r':
				{
					gchar* _tmp35_;
					gint _tmp35__length1;
					gint _tmp36_;
					gchar _tmp37_;
					gint _tmp38_;
					_tmp35_ = rv;
					_tmp35__length1 = rv_length1;
					_tmp36_ = j;
					j = _tmp36_ + 1;
					_tmp35_[_tmp36_] = '\r';
					_tmp37_ = _tmp35_[_tmp36_];
					_tmp38_ = i;
					i = _tmp38_ + 2;
					break;
				}
				case 'v':
				{
					gchar* _tmp39_;
					gint _tmp39__length1;
					gint _tmp40_;
					gchar _tmp41_;
					gint _tmp42_;
					_tmp39_ = rv;
					_tmp39__length1 = rv_length1;
					_tmp40_ = j;
					j = _tmp40_ + 1;
					_tmp39_[_tmp40_] = '\xb';
					_tmp41_ = _tmp39_[_tmp40_];
					_tmp42_ = i;
					i = _tmp42_ + 2;
					break;
				}
				case 'a':
				{
					gchar* _tmp43_;
					gint _tmp43__length1;
					gint _tmp44_;
					gchar _tmp45_;
					gint _tmp46_;
					_tmp43_ = rv;
					_tmp43__length1 = rv_length1;
					_tmp44_ = j;
					j = _tmp44_ + 1;
					_tmp43_[_tmp44_] = '\x7';
					_tmp45_ = _tmp43_[_tmp44_];
					_tmp46_ = i;
					i = _tmp46_ + 2;
					break;
				}
				case 'x':
				{
					gboolean _tmp47_ = FALSE;
					gchar* _tmp48_;
					gint _tmp48__length1;
					gint _tmp49_;
					gchar _tmp50_;
					gboolean _tmp54_;
					_tmp48_ = s;
					_tmp48__length1 = s_length1;
					_tmp49_ = i;
					_tmp50_ = _tmp48_[_tmp49_ + 2];
					if (((gint) _tmp50_) != 0) {
						gchar* _tmp51_;
						gint _tmp51__length1;
						gint _tmp52_;
						gchar _tmp53_;
						_tmp51_ = s;
						_tmp51__length1 = s_length1;
						_tmp52_ = i;
						_tmp53_ = _tmp51_[_tmp52_ + 3];
						_tmp47_ = ((gint) _tmp53_) != 0;
					} else {
						_tmp47_ = FALSE;
					}
					_tmp54_ = _tmp47_;
					if (_tmp54_) {
						gchar* _tmp55_ = NULL;
						gchar* tmpstr;
						gint tmpstr_length1;
						gint _tmpstr_size_;
						gchar* _tmp56_;
						gint _tmp56__length1;
						gchar* _tmp57_;
						gint _tmp57__length1;
						gint _tmp58_;
						gchar _tmp59_;
						gchar _tmp60_;
						gchar* _tmp61_;
						gint _tmp61__length1;
						gchar* _tmp62_;
						gint _tmp62__length1;
						gint _tmp63_;
						gchar _tmp64_;
						gchar _tmp65_;
						gchar* _tmp66_;
						gint _tmp66__length1;
						gulong _tmp67_ = 0UL;
						gulong val;
						gchar* _tmp68_;
						gint _tmp68__length1;
						gint _tmp69_;
						gulong _tmp70_;
						gchar _tmp71_;
						gint _tmp72_;
						_tmp55_ = g_new0 (gchar, 3);
						tmpstr = _tmp55_;
						tmpstr_length1 = 3;
						_tmpstr_size_ = tmpstr_length1;
						_tmp56_ = tmpstr;
						_tmp56__length1 = tmpstr_length1;
						_tmp57_ = s;
						_tmp57__length1 = s_length1;
						_tmp58_ = i;
						_tmp59_ = _tmp57_[_tmp58_ + 2];
						_tmp56_[0] = _tmp59_;
						_tmp60_ = _tmp56_[0];
						_tmp61_ = tmpstr;
						_tmp61__length1 = tmpstr_length1;
						_tmp62_ = s;
						_tmp62__length1 = s_length1;
						_tmp63_ = i;
						_tmp64_ = _tmp62_[_tmp63_ + 3];
						_tmp61_[1] = _tmp64_;
						_tmp65_ = _tmp61_[1];
						_tmp66_ = tmpstr;
						_tmp66__length1 = tmpstr_length1;
						_tmp67_ = strtoul ((const gchar*) _tmp66_, NULL, 16);
						val = _tmp67_;
						_tmp68_ = rv;
						_tmp68__length1 = rv_length1;
						_tmp69_ = j;
						j = _tmp69_ + 1;
						_tmp70_ = val;
						_tmp68_[_tmp69_] = (gchar) _tmp70_;
						_tmp71_ = _tmp68_[_tmp69_];
						_tmp72_ = i;
						i = _tmp72_ + 4;
						tmpstr = (g_free (tmpstr), NULL);
					} else {
						bare_escape = TRUE;
					}
					break;
				}
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				{
					gboolean _tmp73_ = FALSE;
					gboolean _tmp74_ = FALSE;
					gchar* _tmp75_;
					gint _tmp75__length1;
					gint _tmp76_;
					gchar _tmp77_;
					gboolean _tmp81_;
					gboolean _tmp85_;
					_tmp75_ = s;
					_tmp75__length1 = s_length1;
					_tmp76_ = i;
					_tmp77_ = _tmp75_[_tmp76_ + 2];
					if (((gint) _tmp77_) != 0) {
						gchar* _tmp78_;
						gint _tmp78__length1;
						gint _tmp79_;
						gchar _tmp80_;
						_tmp78_ = s;
						_tmp78__length1 = s_length1;
						_tmp79_ = i;
						_tmp80_ = _tmp78_[_tmp79_ + 3];
						_tmp74_ = ((gint) _tmp80_) != 0;
					} else {
						_tmp74_ = FALSE;
					}
					_tmp81_ = _tmp74_;
					if (_tmp81_) {
						gchar* _tmp82_;
						gint _tmp82__length1;
						gint _tmp83_;
						gchar _tmp84_;
						_tmp82_ = s;
						_tmp82__length1 = s_length1;
						_tmp83_ = i;
						_tmp84_ = _tmp82_[_tmp83_ + 4];
						_tmp73_ = ((gint) _tmp84_) != 0;
					} else {
						_tmp73_ = FALSE;
					}
					_tmp85_ = _tmp73_;
					if (_tmp85_) {
						gchar* _tmp86_ = NULL;
						gchar* tmpstr;
						gint tmpstr_length1;
						gint _tmpstr_size_;
						gchar* _tmp87_;
						gint _tmp87__length1;
						gchar* _tmp88_;
						gint _tmp88__length1;
						gint _tmp89_;
						gchar _tmp90_;
						gchar _tmp91_;
						gchar* _tmp92_;
						gint _tmp92__length1;
						gchar* _tmp93_;
						gint _tmp93__length1;
						gint _tmp94_;
						gchar _tmp95_;
						gchar _tmp96_;
						gchar* _tmp97_;
						gint _tmp97__length1;
						gchar* _tmp98_;
						gint _tmp98__length1;
						gint _tmp99_;
						gchar _tmp100_;
						gchar _tmp101_;
						gchar* _tmp102_;
						gint _tmp102__length1;
						gulong _tmp103_ = 0UL;
						gulong val;
						gchar* _tmp104_;
						gint _tmp104__length1;
						gint _tmp105_;
						gulong _tmp106_;
						gchar _tmp107_;
						gint _tmp108_;
						_tmp86_ = g_new0 (gchar, 4);
						tmpstr = _tmp86_;
						tmpstr_length1 = 4;
						_tmpstr_size_ = tmpstr_length1;
						_tmp87_ = tmpstr;
						_tmp87__length1 = tmpstr_length1;
						_tmp88_ = s;
						_tmp88__length1 = s_length1;
						_tmp89_ = i;
						_tmp90_ = _tmp88_[_tmp89_ + 2];
						_tmp87_[0] = _tmp90_;
						_tmp91_ = _tmp87_[0];
						_tmp92_ = tmpstr;
						_tmp92__length1 = tmpstr_length1;
						_tmp93_ = s;
						_tmp93__length1 = s_length1;
						_tmp94_ = i;
						_tmp95_ = _tmp93_[_tmp94_ + 3];
						_tmp92_[1] = _tmp95_;
						_tmp96_ = _tmp92_[1];
						_tmp97_ = tmpstr;
						_tmp97__length1 = tmpstr_length1;
						_tmp98_ = s;
						_tmp98__length1 = s_length1;
						_tmp99_ = i;
						_tmp100_ = _tmp98_[_tmp99_ + 4];
						_tmp97_[2] = _tmp100_;
						_tmp101_ = _tmp97_[2];
						_tmp102_ = tmpstr;
						_tmp102__length1 = tmpstr_length1;
						_tmp103_ = strtoul ((const gchar*) _tmp102_, NULL, 8);
						val = _tmp103_;
						_tmp104_ = rv;
						_tmp104__length1 = rv_length1;
						_tmp105_ = j;
						j = _tmp105_ + 1;
						_tmp106_ = val;
						_tmp104_[_tmp105_] = (gchar) _tmp106_;
						_tmp107_ = _tmp104_[_tmp105_];
						_tmp108_ = i;
						i = _tmp108_ + 5;
						tmpstr = (g_free (tmpstr), NULL);
					} else {
						bare_escape = TRUE;
					}
					break;
				}
				default:
				{
					bare_escape = TRUE;
					break;
				}
			}
			_tmp109_ = bare_escape;
			if (_tmp109_) {
				gchar* _tmp110_;
				gint _tmp110__length1;
				gint _tmp111_;
				gchar* _tmp112_;
				gint _tmp112__length1;
				gint _tmp113_;
				gchar _tmp114_;
				gchar _tmp115_;
				gint _tmp116_;
				_tmp110_ = rv;
				_tmp110__length1 = rv_length1;
				_tmp111_ = j;
				j = _tmp111_ + 1;
				_tmp112_ = s;
				_tmp112__length1 = s_length1;
				_tmp113_ = i;
				_tmp114_ = _tmp112_[_tmp113_ + 1];
				_tmp110_[_tmp111_] = _tmp114_;
				_tmp115_ = _tmp110_[_tmp111_];
				_tmp116_ = i;
				i = _tmp116_ + 2;
			}
		} else {
			gchar* _tmp117_;
			gint _tmp117__length1;
			gint _tmp118_;
			gchar* _tmp119_;
			gint _tmp119__length1;
			gint _tmp120_;
			gchar _tmp121_;
			gchar _tmp122_;
			_tmp117_ = rv;
			_tmp117__length1 = rv_length1;
			_tmp118_ = j;
			j = _tmp118_ + 1;
			_tmp119_ = s;
			_tmp119__length1 = s_length1;
			_tmp120_ = i;
			i = _tmp120_ + 1;
			_tmp121_ = _tmp119_[_tmp120_];
			_tmp117_[_tmp118_] = _tmp121_;
			_tmp122_ = _tmp117_[_tmp118_];
		}
	}
	_tmp123_ = rv;
	_tmp123__length1 = rv_length1;
	_tmp124_ = g_strdup ((const gchar*) _tmp123_);
	result = _tmp124_;
	rv = (g_free (rv), NULL);
	return result;
}


static gchar* string_chomp (const gchar* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _result_;
	const gchar* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	_tmp1_ = _result_;
	g_strchomp (_tmp1_);
	result = _result_;
	return result;
}


static glong string_strnlen (gchar* str, glong maxlen) {
	glong result = 0L;
	gchar* _tmp0_;
	glong _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* end;
	gchar* _tmp3_;
	_tmp0_ = str;
	_tmp1_ = maxlen;
	_tmp2_ = memchr (_tmp0_, 0, (gsize) _tmp1_);
	end = _tmp2_;
	_tmp3_ = end;
	if (_tmp3_ == NULL) {
		glong _tmp4_;
		_tmp4_ = maxlen;
		result = _tmp4_;
		return result;
	} else {
		gchar* _tmp5_;
		gchar* _tmp6_;
		_tmp5_ = end;
		_tmp6_ = str;
		result = (glong) (_tmp5_ - _tmp6_);
		return result;
	}
}


static gchar* string_substring (const gchar* self, glong offset, glong len) {
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	glong _tmp1_;
	gboolean _tmp3_;
	glong _tmp9_;
	glong _tmp15_;
	glong _tmp18_;
	glong _tmp19_;
	glong _tmp20_;
	glong _tmp21_;
	glong _tmp22_;
	gchar* _tmp23_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = offset;
	if (_tmp1_ >= ((glong) 0)) {
		glong _tmp2_;
		_tmp2_ = len;
		_tmp0_ = _tmp2_ >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	_tmp3_ = _tmp0_;
	if (_tmp3_) {
		glong _tmp4_;
		glong _tmp5_;
		glong _tmp6_ = 0L;
		_tmp4_ = offset;
		_tmp5_ = len;
		_tmp6_ = string_strnlen ((gchar*) self, _tmp4_ + _tmp5_);
		string_length = _tmp6_;
	} else {
		gint _tmp7_;
		gint _tmp8_;
		_tmp7_ = strlen (self);
		_tmp8_ = _tmp7_;
		string_length = (glong) _tmp8_;
	}
	_tmp9_ = offset;
	if (_tmp9_ < ((glong) 0)) {
		glong _tmp10_;
		glong _tmp11_;
		glong _tmp12_;
		_tmp10_ = string_length;
		_tmp11_ = offset;
		offset = _tmp10_ + _tmp11_;
		_tmp12_ = offset;
		g_return_val_if_fail (_tmp12_ >= ((glong) 0), NULL);
	} else {
		glong _tmp13_;
		glong _tmp14_;
		_tmp13_ = offset;
		_tmp14_ = string_length;
		g_return_val_if_fail (_tmp13_ <= _tmp14_, NULL);
	}
	_tmp15_ = len;
	if (_tmp15_ < ((glong) 0)) {
		glong _tmp16_;
		glong _tmp17_;
		_tmp16_ = string_length;
		_tmp17_ = offset;
		len = _tmp16_ - _tmp17_;
	}
	_tmp18_ = offset;
	_tmp19_ = len;
	_tmp20_ = string_length;
	g_return_val_if_fail ((_tmp18_ + _tmp19_) <= _tmp20_, NULL);
	_tmp21_ = offset;
	_tmp22_ = len;
	_tmp23_ = g_strndup (((gchar*) self) + _tmp21_, (gsize) _tmp22_);
	result = _tmp23_;
	return result;
}


static void duplicity_instance_split_line (const gchar* line, gchar*** split, int* split_length1) {
	gchar** _vala_split = NULL;
	int _vala_split_length1 = 0;
	const gchar* _tmp0_;
	gchar** _tmp1_;
	gchar** _tmp2_ = NULL;
	gchar** firstsplit;
	gint firstsplit_length1;
	gint _firstsplit_size_;
	GList* splitlist;
	gint i = 0;
	gboolean in_group;
	gchar* _tmp3_;
	gchar* group_word;
	GList* _tmp60_;
	guint _tmp61_ = 0U;
	gchar** _tmp62_ = NULL;
	GList* _tmp63_;
	g_return_if_fail (line != NULL);
	_tmp0_ = line;
	_tmp2_ = _tmp1_ = g_strsplit (_tmp0_, " ", 0);
	firstsplit = _tmp2_;
	firstsplit_length1 = _vala_array_length (_tmp1_);
	_firstsplit_size_ = firstsplit_length1;
	splitlist = NULL;
	in_group = FALSE;
	_tmp3_ = g_strdup ("");
	group_word = _tmp3_;
	{
		gboolean _tmp4_;
		i = 0;
		_tmp4_ = TRUE;
		while (TRUE) {
			gboolean _tmp5_;
			gchar** _tmp7_;
			gint _tmp7__length1;
			gint _tmp8_;
			const gchar* _tmp9_;
			gchar** _tmp10_;
			gint _tmp10__length1;
			gint _tmp11_;
			const gchar* _tmp12_;
			gchar* _tmp13_;
			gchar* word;
			gchar** _tmp14_;
			gint _tmp14__length1;
			gint _tmp15_;
			const gchar* _tmp16_;
			gboolean _tmp19_ = FALSE;
			gboolean _tmp20_;
			gboolean _tmp23_;
			gboolean _tmp24_;
			_tmp5_ = _tmp4_;
			if (!_tmp5_) {
				gint _tmp6_;
				_tmp6_ = i;
				i = _tmp6_ + 1;
			}
			_tmp4_ = FALSE;
			_tmp7_ = firstsplit;
			_tmp7__length1 = firstsplit_length1;
			_tmp8_ = i;
			_tmp9_ = _tmp7_[_tmp8_];
			if (!(_tmp9_ != NULL)) {
				break;
			}
			_tmp10_ = firstsplit;
			_tmp10__length1 = firstsplit_length1;
			_tmp11_ = i;
			_tmp12_ = _tmp10_[_tmp11_];
			_tmp13_ = g_strdup (_tmp12_);
			word = _tmp13_;
			_tmp14_ = firstsplit;
			_tmp14__length1 = firstsplit_length1;
			_tmp15_ = i;
			_tmp16_ = _tmp14_[_tmp15_ + 1];
			if (_tmp16_ == NULL) {
				const gchar* _tmp17_;
				gchar* _tmp18_ = NULL;
				_tmp17_ = word;
				_tmp18_ = string_chomp (_tmp17_);
				_g_free0 (word);
				word = _tmp18_;
			}
			_tmp20_ = in_group;
			if (!_tmp20_) {
				const gchar* _tmp21_;
				gboolean _tmp22_ = FALSE;
				_tmp21_ = word;
				_tmp22_ = g_str_has_prefix (_tmp21_, "\'");
				_tmp19_ = _tmp22_;
			} else {
				_tmp19_ = FALSE;
			}
			_tmp23_ = _tmp19_;
			if (_tmp23_) {
				in_group = TRUE;
			}
			_tmp24_ = in_group;
			if (_tmp24_) {
				gboolean _tmp25_ = FALSE;
				const gchar* _tmp26_;
				gboolean _tmp27_ = FALSE;
				gboolean _tmp33_;
				const gchar* _tmp41_;
				gchar* _tmp42_ = NULL;
				const gchar* _tmp43_;
				gboolean _tmp51_;
				_tmp26_ = word;
				_tmp27_ = g_str_has_suffix (_tmp26_, "\'");
				if (_tmp27_) {
					const gchar* _tmp28_;
					const gchar* _tmp29_;
					gint _tmp30_;
					gint _tmp31_;
					gint _tmp32_ = 0;
					_tmp28_ = word;
					_tmp29_ = word;
					_tmp30_ = strlen (_tmp29_);
					_tmp31_ = _tmp30_;
					_tmp32_ = duplicity_instance_num_suffix (_tmp28_, '\\', ((glong) _tmp31_) - 2);
					_tmp25_ = (_tmp32_ % 2) == 0;
				} else {
					_tmp25_ = FALSE;
				}
				_tmp33_ = _tmp25_;
				if (_tmp33_) {
					in_group = FALSE;
				} else {
					const gchar* _tmp34_;
					gint _tmp35_ = 0;
					_tmp34_ = word;
					_tmp35_ = duplicity_instance_num_suffix (_tmp34_, '\\', (glong) (-1));
					if ((_tmp35_ % 2) == 1) {
						const gchar* _tmp36_;
						const gchar* _tmp37_;
						gint _tmp38_;
						gint _tmp39_;
						gchar* _tmp40_ = NULL;
						_tmp36_ = word;
						_tmp37_ = word;
						_tmp38_ = strlen (_tmp37_);
						_tmp39_ = _tmp38_;
						_tmp40_ = string_substring (_tmp36_, (glong) 0, (glong) (_tmp39_ - 2));
						_g_free0 (word);
						word = _tmp40_;
					}
				}
				_tmp41_ = word;
				_tmp42_ = duplicity_instance_compress_string (_tmp41_);
				_g_free0 (word);
				word = _tmp42_;
				_tmp43_ = group_word;
				if (g_strcmp0 (_tmp43_, "") == 0) {
					const gchar* _tmp44_;
					gchar* _tmp45_;
					_tmp44_ = word;
					_tmp45_ = g_strdup (_tmp44_);
					_g_free0 (group_word);
					group_word = _tmp45_;
				} else {
					const gchar* _tmp46_;
					const gchar* _tmp47_;
					gchar* _tmp48_;
					gchar* _tmp49_;
					gchar* _tmp50_;
					_tmp46_ = group_word;
					_tmp47_ = word;
					_tmp48_ = g_strconcat (" ", _tmp47_, NULL);
					_tmp49_ = _tmp48_;
					_tmp50_ = g_strconcat (_tmp46_, _tmp49_, NULL);
					_g_free0 (group_word);
					group_word = _tmp50_;
					_g_free0 (_tmp49_);
				}
				_tmp51_ = in_group;
				if (!_tmp51_) {
					const gchar* _tmp52_;
					const gchar* _tmp53_;
					gint _tmp54_;
					gint _tmp55_;
					gchar* _tmp56_ = NULL;
					gchar* _tmp57_;
					_tmp52_ = group_word;
					_tmp53_ = group_word;
					_tmp54_ = strlen (_tmp53_);
					_tmp55_ = _tmp54_;
					_tmp56_ = string_substring (_tmp52_, (glong) 1, (glong) (_tmp55_ - 2));
					splitlist = g_list_append (splitlist, _tmp56_);
					_tmp57_ = g_strdup ("");
					_g_free0 (group_word);
					group_word = _tmp57_;
				}
			} else {
				const gchar* _tmp58_;
				gchar* _tmp59_;
				_tmp58_ = word;
				_tmp59_ = g_strdup (_tmp58_);
				splitlist = g_list_append (splitlist, _tmp59_);
			}
			_g_free0 (word);
		}
	}
	_tmp60_ = splitlist;
	_tmp61_ = g_list_length (_tmp60_);
	_tmp62_ = g_new0 (gchar*, _tmp61_ + 1);
	_vala_split = (_vala_array_free (_vala_split, _vala_split_length1, (GDestroyNotify) g_free), NULL);
	_vala_split = _tmp62_;
	_vala_split_length1 = _tmp61_;
	i = 0;
	_tmp63_ = splitlist;
	{
		GList* s_collection = NULL;
		GList* s_it = NULL;
		s_collection = _tmp63_;
		for (s_it = s_collection; s_it != NULL; s_it = s_it->next) {
			gchar* _tmp64_;
			gchar* s = NULL;
			_tmp64_ = g_strdup ((const gchar*) s_it->data);
			s = _tmp64_;
			{
				gchar** _tmp65_;
				gint _tmp65__length1;
				gint _tmp66_;
				const gchar* _tmp67_;
				gchar* _tmp68_;
				gchar* _tmp69_;
				_tmp65_ = _vala_split;
				_tmp65__length1 = _vala_split_length1;
				_tmp66_ = i;
				i = _tmp66_ + 1;
				_tmp67_ = s;
				_tmp68_ = g_strdup (_tmp67_);
				_g_free0 (_tmp65_[_tmp66_]);
				_tmp65_[_tmp66_] = _tmp68_;
				_tmp69_ = _tmp65_[_tmp66_];
				_g_free0 (s);
			}
		}
	}
	_g_free0 (group_word);
	__g_list_free__g_free0_0 (splitlist);
	firstsplit = (_vala_array_free (firstsplit, firstsplit_length1, (GDestroyNotify) g_free), NULL);
	if (split) {
		*split = _vala_split;
	} else {
		_vala_split = (_vala_array_free (_vala_split, _vala_split_length1, (GDestroyNotify) g_free), NULL);
	}
	if (split_length1) {
		*split_length1 = _vala_split_length1;
	}
}


static void duplicity_instance_process_stanza (DuplicityInstance* self, GList* stanza) {
	gchar** control_line = NULL;
	gint control_line_length1 = 0;
	gint _control_line_size_ = 0;
	GList* _tmp0_;
	gconstpointer _tmp1_;
	gchar** _tmp2_ = NULL;
	gint _tmp3_ = 0;
	GList* _tmp4_;
	GList* _tmp5_ = NULL;
	GList* data;
	GList* _tmp6_;
	gchar* _tmp7_ = NULL;
	gchar* text;
	g_return_if_fail (self != NULL);
	_tmp0_ = stanza;
	_tmp1_ = _tmp0_->data;
	duplicity_instance_split_line ((const gchar*) _tmp1_, &_tmp2_, &_tmp3_);
	control_line = (_vala_array_free (control_line, control_line_length1, (GDestroyNotify) g_free), NULL);
	control_line = _tmp2_;
	control_line_length1 = _tmp3_;
	_control_line_size_ = control_line_length1;
	_tmp4_ = stanza;
	_tmp5_ = duplicity_instance_grab_stanza_data (self, _tmp4_);
	data = _tmp5_;
	_tmp6_ = stanza;
	_tmp7_ = duplicity_instance_grab_stanza_text (self, _tmp6_);
	text = _tmp7_;
	self->priv->processed_a_message = TRUE;
	g_signal_emit_by_name (self, "message", control_line, control_line_length1, data, text);
	_g_free0 (text);
	__g_list_free__g_free0_0 (data);
	control_line = (_vala_array_free (control_line, control_line_length1, (GDestroyNotify) g_free), NULL);
}


static GList* duplicity_instance_grab_stanza_data (DuplicityInstance* self, GList* stanza) {
	GList* result = NULL;
	GList* list;
	GList* _tmp0_;
	GList* _tmp1_;
	GList* _tmp2_;
	g_return_val_if_fail (self != NULL, NULL);
	list = NULL;
	_tmp0_ = stanza;
	_tmp1_ = _tmp0_->next;
	stanza = _tmp1_;
	_tmp2_ = stanza;
	{
		GList* line_collection = NULL;
		GList* line_it = NULL;
		line_collection = _tmp2_;
		for (line_it = line_collection; line_it != NULL; line_it = line_it->next) {
			gchar* _tmp3_;
			gchar* line = NULL;
			_tmp3_ = g_strdup ((const gchar*) line_it->data);
			line = _tmp3_;
			{
				const gchar* _tmp4_;
				gboolean _tmp5_ = FALSE;
				_tmp4_ = line;
				_tmp5_ = g_str_has_prefix (_tmp4_, ". ");
				if (!_tmp5_) {
					const gchar* _tmp6_;
					gchar* _tmp7_ = NULL;
					gchar* _tmp8_;
					gchar* _tmp9_ = NULL;
					_tmp6_ = line;
					_tmp7_ = string_chomp (_tmp6_);
					_tmp8_ = _tmp7_;
					_tmp9_ = duplicity_instance_validated_string (_tmp8_);
					list = g_list_append (list, _tmp9_);
					_g_free0 (_tmp8_);
				}
				_g_free0 (line);
			}
		}
	}
	result = list;
	return result;
}


static gchar* duplicity_instance_grab_stanza_text (DuplicityInstance* self, GList* stanza) {
	gchar* result = NULL;
	gchar* _tmp0_;
	gchar* text;
	GList* _tmp1_;
	const gchar* _tmp14_;
	gchar* _tmp15_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("");
	text = _tmp0_;
	_tmp1_ = stanza;
	{
		GList* line_collection = NULL;
		GList* line_it = NULL;
		line_collection = _tmp1_;
		for (line_it = line_collection; line_it != NULL; line_it = line_it->next) {
			gchar* _tmp2_;
			gchar* line = NULL;
			_tmp2_ = g_strdup ((const gchar*) line_it->data);
			line = _tmp2_;
			{
				const gchar* _tmp3_;
				gboolean _tmp4_ = FALSE;
				_tmp3_ = line;
				_tmp4_ = g_str_has_prefix (_tmp3_, ". ");
				if (_tmp4_) {
					const gchar* _tmp5_;
					gchar** _tmp6_;
					gchar** _tmp7_ = NULL;
					gchar** split;
					gint split_length1;
					gint _split_size_;
					const gchar* _tmp8_;
					gchar** _tmp9_;
					gint _tmp9__length1;
					const gchar* _tmp10_;
					gchar* _tmp11_ = NULL;
					gchar* _tmp12_;
					gchar* _tmp13_ = NULL;
					_tmp5_ = line;
					_tmp7_ = _tmp6_ = g_strsplit (_tmp5_, ". ", 2);
					split = _tmp7_;
					split_length1 = _vala_array_length (_tmp6_);
					_split_size_ = split_length1;
					_tmp8_ = text;
					_tmp9_ = split;
					_tmp9__length1 = split_length1;
					_tmp10_ = _tmp9_[1];
					_tmp11_ = duplicity_instance_validated_string (_tmp10_);
					_tmp12_ = _tmp11_;
					_tmp13_ = g_strdup_printf ("%s%s\n", _tmp8_, _tmp12_);
					_g_free0 (text);
					text = _tmp13_;
					_g_free0 (_tmp12_);
					split = (_vala_array_free (split, split_length1, (GDestroyNotify) g_free), NULL);
				}
				_g_free0 (line);
			}
		}
	}
	_tmp14_ = text;
	_tmp15_ = string_chomp (_tmp14_);
	result = _tmp15_;
	_g_free0 (text);
	return result;
}


static void duplicity_instance_spawn_finished (DuplicityInstance* self, GPid pid, gint status) {
	gint _tmp0_;
	gint _tmp1_;
	gboolean _tmp2_ = FALSE;
	GPid _tmp8_;
	GDataInputStream* _tmp9_;
	g_return_if_fail (self != NULL);
	_tmp0_ = status;
	self->priv->status = _tmp0_;
	_tmp1_ = status;
	_tmp2_ = WIFEXITED (_tmp1_);
	if (_tmp2_) {
		gint _tmp3_;
		gint _tmp4_ = 0;
		gint exitval;
		GPid _tmp5_;
		gint _tmp6_;
		_tmp3_ = status;
		_tmp4_ = WEXITSTATUS (_tmp3_);
		exitval = _tmp4_;
		_tmp5_ = pid;
		_tmp6_ = exitval;
		g_debug ("DuplicityInstance.vala:563: duplicity (%i) exited with value %i\n", (gint) _tmp5_, _tmp6_);
	} else {
		GPid _tmp7_;
		_tmp7_ = pid;
		g_debug ("DuplicityInstance.vala:566: duplicity (%i) process killed\n", (gint) _tmp7_);
	}
	self->priv->watch_id = (guint) 0;
	_tmp8_ = pid;
	g_spawn_close_pid (_tmp8_);
	self->priv->process_done = TRUE;
	_tmp9_ = self->priv->reader;
	if (_tmp9_ == NULL) {
		duplicity_instance_send_done_for_status (self);
	}
}


static void duplicity_instance_send_done_for_status (DuplicityInstance* self) {
	gboolean _tmp0_ = FALSE;
	gint _tmp1_;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp5_;
	gboolean success;
	gint _tmp6_;
	gboolean _tmp7_ = FALSE;
	gboolean cancelled;
	gboolean _tmp8_ = FALSE;
	gboolean _tmp9_ = FALSE;
	gint _tmp10_;
	gboolean _tmp11_ = FALSE;
	gboolean _tmp13_;
	gboolean _tmp20_;
	gint _tmp21_;
	gboolean _tmp22_ = FALSE;
	gboolean _tmp25_;
	gboolean _tmp26_;
	g_return_if_fail (self != NULL);
	_tmp1_ = self->priv->status;
	_tmp2_ = WIFEXITED (_tmp1_);
	if (_tmp2_) {
		gint _tmp3_;
		gint _tmp4_ = 0;
		_tmp3_ = self->priv->status;
		_tmp4_ = WEXITSTATUS (_tmp3_);
		_tmp0_ = _tmp4_ == 0;
	} else {
		_tmp0_ = FALSE;
	}
	_tmp5_ = _tmp0_;
	success = _tmp5_;
	_tmp6_ = self->priv->status;
	_tmp7_ = WIFEXITED (_tmp6_);
	cancelled = !_tmp7_;
	_tmp10_ = self->priv->status;
	_tmp11_ = WIFEXITED (_tmp10_);
	if (_tmp11_) {
		gboolean _tmp12_;
		_tmp12_ = self->priv->processed_a_message;
		_tmp9_ = !_tmp12_;
	} else {
		_tmp9_ = FALSE;
	}
	_tmp13_ = _tmp9_;
	if (_tmp13_) {
		gboolean _tmp14_ = FALSE;
		gint _tmp15_;
		gint _tmp16_ = 0;
		gboolean _tmp19_;
		_tmp15_ = self->priv->status;
		_tmp16_ = WEXITSTATUS (_tmp15_);
		if (_tmp16_ == 126) {
			_tmp14_ = TRUE;
		} else {
			gint _tmp17_;
			gint _tmp18_ = 0;
			_tmp17_ = self->priv->status;
			_tmp18_ = WEXITSTATUS (_tmp17_);
			_tmp14_ = _tmp18_ == 127;
		}
		_tmp19_ = _tmp14_;
		_tmp8_ = _tmp19_;
	} else {
		_tmp8_ = FALSE;
	}
	_tmp20_ = _tmp8_;
	if (_tmp20_) {
		cancelled = TRUE;
	}
	_tmp21_ = self->priv->status;
	_tmp22_ = WIFEXITED (_tmp21_);
	if (_tmp22_) {
		gint _tmp23_;
		gint _tmp24_ = 0;
		_tmp23_ = self->priv->status;
		_tmp24_ = WEXITSTATUS (_tmp23_);
		g_signal_emit_by_name (self, "exited", _tmp24_);
	}
	self->priv->child_pid = (GPid) 0;
	_tmp25_ = success;
	_tmp26_ = cancelled;
	g_signal_emit_by_name (self, "done", _tmp25_, _tmp26_);
}


DuplicityInstance* duplicity_instance_construct (GType object_type) {
	DuplicityInstance * self = NULL;
	self = (DuplicityInstance*) g_object_new (object_type, NULL);
	return self;
}


DuplicityInstance* duplicity_instance_new (void) {
	return duplicity_instance_construct (TYPE_DUPLICITY_INSTANCE);
}


gboolean duplicity_instance_get_verbose (DuplicityInstance* self) {
	gboolean result;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_verbose;
	result = _tmp0_;
	return result;
}


static void duplicity_instance_set_verbose (DuplicityInstance* self, gboolean value) {
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_verbose = _tmp0_;
	g_object_notify ((GObject *) self, "verbose");
}


const gchar* duplicity_instance_get_forced_cache_dir (DuplicityInstance* self) {
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_forced_cache_dir;
	result = _tmp0_;
	return result;
}


void duplicity_instance_set_forced_cache_dir (DuplicityInstance* self, const gchar* value) {
	const gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_forced_cache_dir);
	self->priv->_forced_cache_dir = _tmp1_;
	g_object_notify ((GObject *) self, "forced-cache-dir");
}


static void g_cclosure_user_marshal_VOID__BOOLEAN_BOOLEAN (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__BOOLEAN_BOOLEAN) (gpointer data1, gboolean arg_1, gboolean arg_2, gpointer data2);
	register GMarshalFunc_VOID__BOOLEAN_BOOLEAN callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__BOOLEAN_BOOLEAN) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_boolean (param_values + 1), g_value_get_boolean (param_values + 2), data2);
}


static void g_cclosure_user_marshal_VOID__BOXED_INT_POINTER_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__BOXED_INT_POINTER_STRING) (gpointer data1, gpointer arg_1, gint arg_2, gpointer arg_3, const char* arg_4, gpointer data2);
	register GMarshalFunc_VOID__BOXED_INT_POINTER_STRING callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 5);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__BOXED_INT_POINTER_STRING) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_boxed (param_values + 1), g_value_get_int (param_values + 2), g_value_get_pointer (param_values + 3), g_value_get_string (param_values + 4), data2);
}


static GObject * duplicity_instance_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	DuplicityInstance * self;
	gint* _tmp0_ = NULL;
	gint* _tmp1_;
	gint _tmp1__length1;
	gint* _tmp2_;
	gint _tmp2__length1;
	gint _tmp3_;
	gint _tmp4_;
	parent_class = G_OBJECT_CLASS (duplicity_instance_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = DUPLICITY_INSTANCE (obj);
	_tmp0_ = g_new0 (gint, 2);
	self->priv->pipes = (g_free (self->priv->pipes), NULL);
	self->priv->pipes = _tmp0_;
	self->priv->pipes_length1 = 2;
	self->priv->_pipes_size_ = self->priv->pipes_length1;
	_tmp1_ = self->priv->pipes;
	_tmp1__length1 = self->priv->pipes_length1;
	_tmp2_ = self->priv->pipes;
	_tmp2__length1 = self->priv->pipes_length1;
	_tmp2_[1] = -1;
	_tmp3_ = _tmp2_[1];
	_tmp1_[0] = _tmp3_;
	_tmp4_ = _tmp1_[0];
	return obj;
}


static void duplicity_instance_class_init (DuplicityInstanceClass * klass) {
	duplicity_instance_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (DuplicityInstancePrivate));
	DUPLICITY_INSTANCE_CLASS (klass)->start = duplicity_instance_real_start;
	G_OBJECT_CLASS (klass)->get_property = _vala_duplicity_instance_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_duplicity_instance_set_property;
	G_OBJECT_CLASS (klass)->constructor = duplicity_instance_constructor;
	G_OBJECT_CLASS (klass)->finalize = duplicity_instance_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), DUPLICITY_INSTANCE_VERBOSE, g_param_spec_boolean ("verbose", "verbose", "verbose", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), DUPLICITY_INSTANCE_FORCED_CACHE_DIR, g_param_spec_string ("forced-cache-dir", "forced-cache-dir", "forced-cache-dir", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_signal_new ("done", TYPE_DUPLICITY_INSTANCE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__BOOLEAN_BOOLEAN, G_TYPE_NONE, 2, G_TYPE_BOOLEAN, G_TYPE_BOOLEAN);
	g_signal_new ("exited", TYPE_DUPLICITY_INSTANCE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__INT, G_TYPE_NONE, 1, G_TYPE_INT);
	g_signal_new ("message", TYPE_DUPLICITY_INSTANCE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__BOXED_INT_POINTER_STRING, G_TYPE_NONE, 4, G_TYPE_STRV, G_TYPE_INT, G_TYPE_POINTER, G_TYPE_STRING);
}


static void duplicity_instance_instance_init (DuplicityInstance * self) {
	self->priv = DUPLICITY_INSTANCE_GET_PRIVATE (self);
	self->priv->_verbose = FALSE;
	self->priv->_forced_cache_dir = NULL;
}


static void duplicity_instance_finalize (GObject* obj) {
	DuplicityInstance * self;
	guint _tmp0_;
	gboolean _tmp2_ = FALSE;
	GError * _inner_error_ = NULL;
	self = DUPLICITY_INSTANCE (obj);
	_tmp0_ = self->priv->watch_id;
	if (_tmp0_ != ((guint) 0)) {
		guint _tmp1_;
		_tmp1_ = self->priv->watch_id;
		g_source_remove (_tmp1_);
	}
	_tmp2_ = duplicity_instance_is_started (self);
	if (_tmp2_) {
		GPid _tmp3_;
		_tmp3_ = self->priv->child_pid;
		g_debug ("DuplicityInstance.vala:246: duplicity (%i) process killed\n", (gint) _tmp3_);
		duplicity_instance_kill_child (self);
	}
	{
		GFile* _tmp4_;
		_tmp4_ = self->priv->scriptfile;
		if (_tmp4_ != NULL) {
			GFile* _tmp5_;
			_tmp5_ = self->priv->scriptfile;
			g_file_delete (_tmp5_, NULL, &_inner_error_);
			if (_inner_error_ != NULL) {
				goto __catch0_g_error;
			}
		}
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp6_;
		const gchar* _tmp7_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp6_ = e;
		_tmp7_ = _tmp6_->message;
		g_warning ("DuplicityInstance.vala:254: %s\n", _tmp7_);
		_g_error_free0 (e);
	}
	__finally0:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
	}
	_g_free0 (self->priv->_forced_cache_dir);
	self->priv->pipes = (g_free (self->priv->pipes), NULL);
	_g_object_unref0 (self->priv->reader);
	_g_object_unref0 (self->priv->logfile);
	_g_object_unref0 (self->priv->scriptfile);
	G_OBJECT_CLASS (duplicity_instance_parent_class)->finalize (obj);
}


GType duplicity_instance_get_type (void) {
	return duplicity_instance_type_id;
}


GType duplicity_instance_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (DuplicityInstanceClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) duplicity_instance_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (DuplicityInstance), 0, (GInstanceInitFunc) duplicity_instance_instance_init, NULL };
	duplicity_instance_type_id = g_type_module_register_type (module, G_TYPE_OBJECT, "DuplicityInstance", &g_define_type_info, 0);
	return duplicity_instance_type_id;
}


static void _vala_duplicity_instance_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	DuplicityInstance * self;
	self = DUPLICITY_INSTANCE (object);
	switch (property_id) {
		case DUPLICITY_INSTANCE_VERBOSE:
		g_value_set_boolean (value, duplicity_instance_get_verbose (self));
		break;
		case DUPLICITY_INSTANCE_FORCED_CACHE_DIR:
		g_value_set_string (value, duplicity_instance_get_forced_cache_dir (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_duplicity_instance_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	DuplicityInstance * self;
	self = DUPLICITY_INSTANCE (object);
	switch (property_id) {
		case DUPLICITY_INSTANCE_VERBOSE:
		duplicity_instance_set_verbose (self, g_value_get_boolean (value));
		break;
		case DUPLICITY_INSTANCE_FORCED_CACHE_DIR:
		duplicity_instance_set_forced_cache_dir (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



