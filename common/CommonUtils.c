/* CommonUtils.c generated by valac 0.16.1, the Vala compiler
 * generated from CommonUtils.vala, do not modify */

/* -*- Mode: Vala; indent-tabs-mode: nil; tab-width: 2 -*- */
/*
    This file is part of Déjà Dup.
    For copyright information, see AUTHORS.

    Déjà Dup is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Déjà Dup is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Déjà Dup.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <glib/gi18n-lib.h>
#include <float.h>
#include <math.h>
#include <libpeas/peas.h>
#include <config.h>
#include <uriutils.h>


#define DEJA_DUP_TYPE_TIMESTAMP_TYPE (deja_dup_timestamp_type_get_type ())
#define _g_free0(var) (var = (g_free (var), NULL))

#define DEJA_DUP_TYPE_SIMPLE_SETTINGS (deja_dup_simple_settings_get_type ())
#define DEJA_DUP_SIMPLE_SETTINGS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DEJA_DUP_TYPE_SIMPLE_SETTINGS, DejaDupSimpleSettings))
#define DEJA_DUP_SIMPLE_SETTINGS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DEJA_DUP_TYPE_SIMPLE_SETTINGS, DejaDupSimpleSettingsClass))
#define DEJA_DUP_IS_SIMPLE_SETTINGS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DEJA_DUP_TYPE_SIMPLE_SETTINGS))
#define DEJA_DUP_IS_SIMPLE_SETTINGS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DEJA_DUP_TYPE_SIMPLE_SETTINGS))
#define DEJA_DUP_SIMPLE_SETTINGS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DEJA_DUP_TYPE_SIMPLE_SETTINGS, DejaDupSimpleSettingsClass))

typedef struct _DejaDupSimpleSettings DejaDupSimpleSettings;
typedef struct _DejaDupSimpleSettingsClass DejaDupSimpleSettingsClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_date_time_unref0(var) ((var == NULL) ? NULL : (var = (g_date_time_unref (var), NULL)))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))

#define DEJA_DUP_TYPE_TOOL_PLUGIN (deja_dup_tool_plugin_get_type ())
#define DEJA_DUP_TOOL_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DEJA_DUP_TYPE_TOOL_PLUGIN, DejaDupToolPlugin))
#define DEJA_DUP_TOOL_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DEJA_DUP_TYPE_TOOL_PLUGIN, DejaDupToolPluginClass))
#define DEJA_DUP_IS_TOOL_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DEJA_DUP_TYPE_TOOL_PLUGIN))
#define DEJA_DUP_IS_TOOL_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DEJA_DUP_TYPE_TOOL_PLUGIN))
#define DEJA_DUP_TOOL_PLUGIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DEJA_DUP_TYPE_TOOL_PLUGIN, DejaDupToolPluginClass))

typedef struct _DejaDupToolPlugin DejaDupToolPlugin;
typedef struct _DejaDupToolPluginClass DejaDupToolPluginClass;
#define __vala_PeasPluginInfo_free0(var) ((var == NULL) ? NULL : (var = (_vala_PeasPluginInfo_free (var), NULL)))

#define DEJA_DUP_TYPE_TOOL_JOB (deja_dup_tool_job_get_type ())
#define DEJA_DUP_TOOL_JOB(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DEJA_DUP_TYPE_TOOL_JOB, DejaDupToolJob))
#define DEJA_DUP_TOOL_JOB_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DEJA_DUP_TYPE_TOOL_JOB, DejaDupToolJobClass))
#define DEJA_DUP_IS_TOOL_JOB(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DEJA_DUP_TYPE_TOOL_JOB))
#define DEJA_DUP_IS_TOOL_JOB_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DEJA_DUP_TYPE_TOOL_JOB))
#define DEJA_DUP_TOOL_JOB_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DEJA_DUP_TYPE_TOOL_JOB, DejaDupToolJobClass))

typedef struct _DejaDupToolJob DejaDupToolJob;
typedef struct _DejaDupToolJobClass DejaDupToolJobClass;

#define DEJA_DUP_TYPE_BACKEND (deja_dup_backend_get_type ())
#define DEJA_DUP_BACKEND(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DEJA_DUP_TYPE_BACKEND, DejaDupBackend))
#define DEJA_DUP_BACKEND_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DEJA_DUP_TYPE_BACKEND, DejaDupBackendClass))
#define DEJA_DUP_IS_BACKEND(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DEJA_DUP_TYPE_BACKEND))
#define DEJA_DUP_IS_BACKEND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DEJA_DUP_TYPE_BACKEND))
#define DEJA_DUP_BACKEND_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DEJA_DUP_TYPE_BACKEND, DejaDupBackendClass))

typedef struct _DejaDupBackend DejaDupBackend;
typedef struct _DejaDupBackendClass DejaDupBackendClass;
#define _deja_dup_decoded_uri_free0(var) ((var == NULL) ? NULL : (var = (deja_dup_decoded_uri_free (var), NULL)))
typedef struct _DejaDupGetNicknameData DejaDupGetNicknameData;

typedef enum  {
	DEJA_DUP_BACKUP_ERROR_BAD_CONFIG,
	DEJA_DUP_BACKUP_ERROR_ALREADY_RUNNING
} DejaDupBackupError;
#define DEJA_DUP_BACKUP_ERROR deja_dup_backup_error_quark ()
typedef enum  {
	DEJA_DUP_TIMESTAMP_TYPE_NONE,
	DEJA_DUP_TIMESTAMP_TYPE_BACKUP,
	DEJA_DUP_TIMESTAMP_TYPE_RESTORE
} DejaDupTimestampType;

struct _DejaDupGetNicknameData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	GFile* f;
	gchar* result;
	gchar* s;
	GFile* _tmp0_;
	GFile* _tmp1_;
	gboolean _tmp2_;
	GFile* _tmp3_;
	GFileInfo* _tmp4_;
	GFileInfo* info;
	const gchar* _tmp5_;
	GFileInfo* _tmp6_;
	const gchar* _tmp7_;
	gchar* _tmp8_;
	GError* e;
	GError* _tmp9_;
	const gchar* _tmp10_;
	const gchar* _tmp11_;
	gchar* _tmp12_;
	GFile* _tmp13_;
	GFile* _tmp14_;
	gboolean _tmp15_;
	const gchar* _tmp16_;
	gchar* _tmp17_;
	GFile* _tmp18_;
	gchar* _tmp19_;
	GError * _inner_error_;
};


extern gboolean deja_dup_settings_read_only;
gboolean deja_dup_settings_read_only = FALSE;
extern GHashTable* deja_dup_settings_table;
GHashTable* deja_dup_settings_table = NULL;
extern DejaDupToolPlugin* deja_dup_tool;
DejaDupToolPlugin* deja_dup_tool = NULL;
extern PeasExtensionBase* deja_dup_apps;
PeasExtensionBase* deja_dup_apps = NULL;
extern GFile* deja_dup_home;
GFile* deja_dup_home = NULL;
extern GFile* deja_dup_trash;
GFile* deja_dup_trash = NULL;

#define DEJA_DUP_INCLUDE_LIST_KEY "include-list"
#define DEJA_DUP_EXCLUDE_LIST_KEY "exclude-list"
#define DEJA_DUP_APPS_LIST_KEY "apps-list"
#define DEJA_DUP_APPS_ROOT "Apps"
#define DEJA_DUP_BACKUP_KEY "backup"
#define DEJA_DUP_BACKEND_KEY "backend"
#define DEJA_DUP_ROOT_PROMPT_KEY "root-prompt"
#define DEJA_DUP_WELCOMED_KEY "welcomed"
#define DEJA_DUP_LAST_RUN_KEY "last-run"
#define DEJA_DUP_LAST_BACKUP_KEY "last-backup"
#define DEJA_DUP_LAST_RESTORE_KEY "last-restore"
#define DEJA_DUP_PROMPT_CHECK_KEY "prompt-check"
#define DEJA_DUP_NAG_CHECK_KEY "nag-check"
#define DEJA_DUP_PERIODIC_KEY "periodic"
#define DEJA_DUP_PERIODIC_PERIOD_KEY "periodic-period"
#define DEJA_DUP_DELETE_AFTER_KEY "delete-after"
#define DEJA_DUP_FULL_BACKUP_PERIOD_KEY "full-backup-period"
GQuark deja_dup_backup_error_quark (void);
GType deja_dup_timestamp_type_get_type (void) G_GNUC_CONST;
gboolean deja_dup_in_testing_mode (void);
void deja_dup_update_last_run_timestamp (DejaDupTimestampType type);
GType deja_dup_simple_settings_get_type (void) G_GNUC_CONST;
DejaDupSimpleSettings* deja_dup_get_settings (const gchar* subdir);
void deja_dup_simple_settings_set_string (DejaDupSimpleSettings* self, const gchar* k, const gchar* v);
void deja_dup_simple_settings_apply (DejaDupSimpleSettings* self);
void deja_dup_run_deja_dup (const gchar* args, GAppLaunchContext* ctx, GList* files);
GDateTime* deja_dup_most_recent_scheduled_date (GTimeSpan period);
gchar* deja_dup_last_run_date (DejaDupTimestampType type);
GTimeSpan deja_dup_get_day (void);
GDateTime* deja_dup_next_run_date (void);
gint deja_dup_get_prompt_delay (void);
gboolean deja_dup_has_seen_settings (void);
void deja_dup_make_prompt_check (void);
void deja_dup_update_prompt_time (gboolean cancel);
void deja_dup_update_time_key (const gchar* key, gboolean cancel);
void deja_dup_update_nag_time (gboolean cancel);
gint deja_dup_get_nag_delay (void);
gboolean deja_dup_is_nag_time (void);
gchar* deja_dup_get_folder_key (DejaDupSimpleSettings* settings, const gchar* key);
void deja_dup_set_settings_read_only (gboolean ro);
DejaDupSimpleSettings* deja_dup_simple_settings_new (const gchar* schema, gboolean ro);
DejaDupSimpleSettings* deja_dup_simple_settings_construct (GType object_type, const gchar* schema, gboolean ro);
DejaDupSimpleSettings* deja_dup_get_app_settings (const gchar* ske, const gchar* subdir);
#define DEJA_DUP_SSH_USERNAME_KEY "username"
#define DEJA_DUP_SSH_SERVER_KEY "server"
#define DEJA_DUP_SSH_PORT_KEY "port"
#define DEJA_DUP_SSH_DIRECTORY_KEY "directory"
void deja_dup_convert_ssh_to_file (void);
#define DEJA_DUP_FILE_ROOT "File"
#define DEJA_DUP_FILE_PATH_KEY "path"
void deja_dup_convert_s3_folder_to_hostname (void);
#define DEJA_DUP_S3_ROOT "S3"
#define DEJA_DUP_S3_FOLDER_KEY "folder"
gchar* deja_dup_backend_get_default_type (void);
GType deja_dup_tool_plugin_get_type (void) G_GNUC_CONST;
void deja_dup_initialize_tool_plugin (GError** error);
static PeasPluginInfo* _vala_PeasPluginInfo_copy (PeasPluginInfo* self);
static void _vala_PeasPluginInfo_free (PeasPluginInfo* self);
void deja_dup_tool_plugin_activate (DejaDupToolPlugin* self);
void deja_dup_initialize_apps_plugin (GError** error);
GType deja_dup_tool_job_get_type (void) G_GNUC_CONST;
DejaDupToolJob* deja_dup_make_tool_job (GError** error);
DejaDupToolJob* deja_dup_tool_plugin_create_job (DejaDupToolPlugin* self, GError** error);
gboolean deja_dup_initialize (gchar** header, gchar** msg);
GType deja_dup_backend_get_type (void) G_GNUC_CONST;
DejaDupBackend* deja_dup_backend_get_default (void);
void deja_dup_i18n_setup (void);
gchar* deja_dup_get_file_desc (GFile* file);
void deja_dup_ensure_special_paths (void);
gchar* deja_dup_get_trash_path (void);
gchar* deja_dup_get_display_name (GFile* f);
static void deja_dup_get_nickname_data_free (gpointer _data);
void deja_dup_get_nickname (GFile* f, GAsyncReadyCallback _callback_, gpointer _user_data_);
gchar* deja_dup_get_nickname_finish (GAsyncResult* _res_);
static gboolean deja_dup_get_nickname_co (DejaDupGetNicknameData* _data_);
static void deja_dup_get_nickname_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
gint deja_dup_get_full_backup_threshold (void);
void deja_dup_get_full_backup_threshold_date (GDate* result);


GQuark deja_dup_backup_error_quark (void) {
	return g_quark_from_static_string ("deja_dup_backup_error-quark");
}


GType deja_dup_timestamp_type_get_type (void) {
	static volatile gsize deja_dup_timestamp_type_type_id__volatile = 0;
	if (g_once_init_enter (&deja_dup_timestamp_type_type_id__volatile)) {
		static const GEnumValue values[] = {{DEJA_DUP_TIMESTAMP_TYPE_NONE, "DEJA_DUP_TIMESTAMP_TYPE_NONE", "none"}, {DEJA_DUP_TIMESTAMP_TYPE_BACKUP, "DEJA_DUP_TIMESTAMP_TYPE_BACKUP", "backup"}, {DEJA_DUP_TIMESTAMP_TYPE_RESTORE, "DEJA_DUP_TIMESTAMP_TYPE_RESTORE", "restore"}, {0, NULL, NULL}};
		GType deja_dup_timestamp_type_type_id;
		deja_dup_timestamp_type_type_id = g_enum_register_static ("DejaDupTimestampType", values);
		g_once_init_leave (&deja_dup_timestamp_type_type_id__volatile, deja_dup_timestamp_type_type_id);
	}
	return deja_dup_timestamp_type_type_id__volatile;
}


gboolean deja_dup_in_testing_mode (void) {
	gboolean result = FALSE;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gchar* testing_str;
	gboolean _tmp2_ = FALSE;
	const gchar* _tmp3_;
	gboolean _tmp6_;
	_tmp0_ = g_getenv ("DEJA_DUP_TESTING");
	_tmp1_ = g_strdup (_tmp0_);
	testing_str = _tmp1_;
	_tmp3_ = testing_str;
	if (_tmp3_ != NULL) {
		const gchar* _tmp4_;
		gint _tmp5_ = 0;
		_tmp4_ = testing_str;
		_tmp5_ = atoi (_tmp4_);
		_tmp2_ = _tmp5_ > 0;
	} else {
		_tmp2_ = FALSE;
	}
	_tmp6_ = _tmp2_;
	result = _tmp6_;
	_g_free0 (testing_str);
	return result;
}


void deja_dup_update_last_run_timestamp (DejaDupTimestampType type) {
	GTimeVal cur_time = {0};
	gchar* _tmp0_ = NULL;
	gchar* cur_time_str;
	DejaDupSimpleSettings* _tmp1_ = NULL;
	DejaDupSimpleSettings* settings;
	DejaDupSimpleSettings* _tmp2_;
	DejaDupSimpleSettings* _tmp3_;
	const gchar* _tmp4_;
	DejaDupTimestampType _tmp5_;
	DejaDupSimpleSettings* _tmp11_;
	g_get_current_time (&cur_time);
	g_get_current_time (&cur_time);
	_tmp0_ = g_time_val_to_iso8601 (&cur_time);
	cur_time_str = _tmp0_;
	_tmp1_ = deja_dup_get_settings (NULL);
	settings = _tmp1_;
	_tmp2_ = settings;
	g_settings_delay ((GSettings*) _tmp2_);
	_tmp3_ = settings;
	_tmp4_ = cur_time_str;
	deja_dup_simple_settings_set_string (_tmp3_, DEJA_DUP_LAST_RUN_KEY, _tmp4_);
	_tmp5_ = type;
	if (_tmp5_ == DEJA_DUP_TIMESTAMP_TYPE_BACKUP) {
		DejaDupSimpleSettings* _tmp6_;
		const gchar* _tmp7_;
		_tmp6_ = settings;
		_tmp7_ = cur_time_str;
		deja_dup_simple_settings_set_string (_tmp6_, DEJA_DUP_LAST_BACKUP_KEY, _tmp7_);
	} else {
		DejaDupTimestampType _tmp8_;
		_tmp8_ = type;
		if (_tmp8_ == DEJA_DUP_TIMESTAMP_TYPE_RESTORE) {
			DejaDupSimpleSettings* _tmp9_;
			const gchar* _tmp10_;
			_tmp9_ = settings;
			_tmp10_ = cur_time_str;
			deja_dup_simple_settings_set_string (_tmp9_, DEJA_DUP_LAST_RESTORE_KEY, _tmp10_);
		}
	}
	_tmp11_ = settings;
	deja_dup_simple_settings_apply (_tmp11_);
	_g_object_unref0 (settings);
	_g_free0 (cur_time_str);
}


void deja_dup_run_deja_dup (const gchar* args, GAppLaunchContext* ctx, GList* files) {
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* cmd;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	gboolean _tmp4_;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_;
	gboolean _tmp9_;
	GAppInfoCreateFlags flags;
	GError * _inner_error_ = NULL;
	g_return_if_fail (args != NULL);
	_tmp0_ = args;
	_tmp1_ = g_strdup_printf ("deja-dup %s", _tmp0_);
	cmd = _tmp1_;
	_tmp2_ = g_find_program_in_path ("ionice");
	_tmp3_ = _tmp2_;
	_tmp4_ = _tmp3_ != NULL;
	_g_free0 (_tmp3_);
	if (_tmp4_) {
		const gchar* _tmp5_;
		gchar* _tmp6_;
		_tmp5_ = cmd;
		_tmp6_ = g_strconcat ("ionice -c2 -n7 ", _tmp5_, NULL);
		_g_free0 (cmd);
		cmd = _tmp6_;
	}
	_tmp7_ = g_find_program_in_path ("nice");
	_tmp8_ = _tmp7_;
	_tmp9_ = _tmp8_ != NULL;
	_g_free0 (_tmp8_);
	if (_tmp9_) {
		const gchar* _tmp10_;
		gchar* _tmp11_;
		_tmp10_ = cmd;
		_tmp11_ = g_strconcat ("nice ", _tmp10_, NULL);
		_g_free0 (cmd);
		cmd = _tmp11_;
	}
	flags = G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION | G_APP_INFO_CREATE_SUPPORTS_URIS;
	{
		const gchar* _tmp12_;
		const gchar* _tmp13_ = NULL;
		GAppInfoCreateFlags _tmp14_;
		GAppInfo* _tmp15_ = NULL;
		GAppInfo* app;
		GAppInfo* _tmp16_;
		GList* _tmp17_;
		GAppLaunchContext* _tmp18_;
		_tmp12_ = cmd;
		_tmp13_ = _ ("Déjà Dup Backup Tool");
		_tmp14_ = flags;
		_tmp15_ = g_app_info_create_from_commandline (_tmp12_, _tmp13_, _tmp14_, &_inner_error_);
		app = _tmp15_;
		if (_inner_error_ != NULL) {
			goto __catch14_g_error;
		}
		_tmp16_ = app;
		_tmp17_ = files;
		_tmp18_ = ctx;
		g_app_info_launch (_tmp16_, _tmp17_, _tmp18_, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_object_unref0 (app);
			goto __catch14_g_error;
		}
		_g_object_unref0 (app);
	}
	goto __finally14;
	__catch14_g_error:
	{
		GError* e = NULL;
		GError* _tmp19_;
		const gchar* _tmp20_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp19_ = e;
		_tmp20_ = _tmp19_->message;
		g_warning ("CommonUtils.vala:97: %s\n", _tmp20_);
		_g_error_free0 (e);
	}
	__finally14:
	if (_inner_error_ != NULL) {
		_g_free0 (cmd);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_free0 (cmd);
}


GDateTime* deja_dup_most_recent_scheduled_date (GTimeSpan period) {
	GDateTime* result = NULL;
	GDateTime* _tmp0_;
	GDateTime* epoch;
	GDateTime* _tmp1_;
	GDateTime* cur_date;
	GTimeSpan _tmp2_ = 0LL;
	GTimeSpan between;
	GTimeSpan _tmp3_;
	GTimeSpan mod;
	GDateTime* _tmp4_ = NULL;
	_tmp0_ = g_date_time_new_from_unix_local ((gint64) 0);
	epoch = _tmp0_;
	_tmp1_ = g_date_time_new_now_local ();
	cur_date = _tmp1_;
	_tmp2_ = g_date_time_difference (cur_date, epoch);
	between = _tmp2_;
	_tmp3_ = period;
	mod = between % _tmp3_;
	_tmp4_ = g_date_time_add (cur_date, (-1) * mod);
	result = _tmp4_;
	_g_date_time_unref0 (cur_date);
	_g_date_time_unref0 (epoch);
	return result;
}


gchar* deja_dup_last_run_date (DejaDupTimestampType type) {
	gchar* result = NULL;
	DejaDupSimpleSettings* _tmp0_ = NULL;
	DejaDupSimpleSettings* settings;
	gchar* last_run_string;
	DejaDupTimestampType _tmp1_;
	gboolean _tmp7_ = FALSE;
	const gchar* _tmp8_;
	gboolean _tmp10_;
	_tmp0_ = deja_dup_get_settings (NULL);
	settings = _tmp0_;
	last_run_string = NULL;
	_tmp1_ = type;
	if (_tmp1_ == DEJA_DUP_TIMESTAMP_TYPE_BACKUP) {
		DejaDupSimpleSettings* _tmp2_;
		gchar* _tmp3_ = NULL;
		_tmp2_ = settings;
		_tmp3_ = g_settings_get_string ((GSettings*) _tmp2_, DEJA_DUP_LAST_BACKUP_KEY);
		_g_free0 (last_run_string);
		last_run_string = _tmp3_;
	} else {
		DejaDupTimestampType _tmp4_;
		_tmp4_ = type;
		if (_tmp4_ == DEJA_DUP_TIMESTAMP_TYPE_RESTORE) {
			DejaDupSimpleSettings* _tmp5_;
			gchar* _tmp6_ = NULL;
			_tmp5_ = settings;
			_tmp6_ = g_settings_get_string ((GSettings*) _tmp5_, DEJA_DUP_LAST_RESTORE_KEY);
			_g_free0 (last_run_string);
			last_run_string = _tmp6_;
		}
	}
	_tmp8_ = last_run_string;
	if (_tmp8_ == NULL) {
		_tmp7_ = TRUE;
	} else {
		const gchar* _tmp9_;
		_tmp9_ = last_run_string;
		_tmp7_ = g_strcmp0 (_tmp9_, "") == 0;
	}
	_tmp10_ = _tmp7_;
	if (_tmp10_) {
		DejaDupSimpleSettings* _tmp11_;
		gchar* _tmp12_ = NULL;
		_tmp11_ = settings;
		_tmp12_ = g_settings_get_string ((GSettings*) _tmp11_, DEJA_DUP_LAST_RUN_KEY);
		_g_free0 (last_run_string);
		last_run_string = _tmp12_;
	}
	result = last_run_string;
	_g_object_unref0 (settings);
	return result;
}


GTimeSpan deja_dup_get_day (void) {
	GTimeSpan result = 0LL;
	gboolean _tmp0_ = FALSE;
	_tmp0_ = deja_dup_in_testing_mode ();
	if (_tmp0_) {
		result = G_TIME_SPAN_SECOND * ((GTimeSpan) 10);
		return result;
	} else {
		result = G_TIME_SPAN_DAY;
		return result;
	}
}


GDateTime* deja_dup_next_run_date (void) {
	GDateTime* result = NULL;
	DejaDupSimpleSettings* _tmp0_ = NULL;
	DejaDupSimpleSettings* settings;
	DejaDupSimpleSettings* _tmp1_;
	gboolean _tmp2_ = FALSE;
	gboolean periodic;
	DejaDupSimpleSettings* _tmp3_;
	gint _tmp4_ = 0;
	gint period_days;
	gchar* _tmp5_ = NULL;
	gchar* last_run_string;
	gboolean _tmp6_;
	const gchar* _tmp7_;
	gint _tmp9_;
	GTimeVal last_run_tval = {0};
	const gchar* _tmp10_;
	gboolean _tmp11_ = FALSE;
	gint _tmp13_;
	GTimeSpan _tmp14_ = 0LL;
	GTimeSpan period;
	GTimeVal _tmp15_;
	GDateTime* _tmp16_;
	GDateTime* last_run;
	GTimeSpan _tmp17_;
	GDateTime* _tmp18_ = NULL;
	GDateTime* last_scheduled;
	GDateTime* _tmp19_;
	GDateTime* _tmp20_;
	gint _tmp21_ = 0;
	_tmp0_ = deja_dup_get_settings (NULL);
	settings = _tmp0_;
	_tmp1_ = settings;
	_tmp2_ = g_settings_get_boolean ((GSettings*) _tmp1_, DEJA_DUP_PERIODIC_KEY);
	periodic = _tmp2_;
	_tmp3_ = settings;
	_tmp4_ = g_settings_get_int ((GSettings*) _tmp3_, DEJA_DUP_PERIODIC_PERIOD_KEY);
	period_days = _tmp4_;
	_tmp5_ = deja_dup_last_run_date (DEJA_DUP_TIMESTAMP_TYPE_BACKUP);
	last_run_string = _tmp5_;
	_tmp6_ = periodic;
	if (!_tmp6_) {
		result = NULL;
		_g_free0 (last_run_string);
		_g_object_unref0 (settings);
		return result;
	}
	_tmp7_ = last_run_string;
	if (g_strcmp0 (_tmp7_, "") == 0) {
		GDateTime* _tmp8_;
		_tmp8_ = g_date_time_new_now_local ();
		result = _tmp8_;
		_g_free0 (last_run_string);
		_g_object_unref0 (settings);
		return result;
	}
	_tmp9_ = period_days;
	if (_tmp9_ <= 0) {
		period_days = 1;
	}
	g_get_current_time (&last_run_tval);
	_tmp10_ = last_run_string;
	_tmp11_ = g_time_val_from_iso8601 (_tmp10_, &last_run_tval);
	if (!_tmp11_) {
		GDateTime* _tmp12_;
		_tmp12_ = g_date_time_new_now_local ();
		result = _tmp12_;
		_g_free0 (last_run_string);
		_g_object_unref0 (settings);
		return result;
	}
	_tmp13_ = period_days;
	_tmp14_ = deja_dup_get_day ();
	period = ((GTimeSpan) _tmp13_) * _tmp14_;
	_tmp15_ = last_run_tval;
	_tmp16_ = g_date_time_new_from_timeval_local (&_tmp15_);
	last_run = _tmp16_;
	_tmp17_ = period;
	_tmp18_ = deja_dup_most_recent_scheduled_date (_tmp17_);
	last_scheduled = _tmp18_;
	_tmp19_ = last_scheduled;
	_tmp20_ = last_run;
	_tmp21_ = g_date_time_compare (_tmp19_, _tmp20_);
	if (_tmp21_ <= 0) {
		GDateTime* _tmp22_;
		GTimeSpan _tmp23_;
		GDateTime* _tmp24_ = NULL;
		_tmp22_ = last_scheduled;
		_tmp23_ = period;
		_tmp24_ = g_date_time_add (_tmp22_, _tmp23_);
		_g_date_time_unref0 (last_scheduled);
		last_scheduled = _tmp24_;
	}
	result = last_scheduled;
	_g_date_time_unref0 (last_run);
	_g_free0 (last_run_string);
	_g_object_unref0 (settings);
	return result;
}


gint deja_dup_get_prompt_delay (void) {
	gint result = 0;
	GTimeSpan span;
	gboolean _tmp0_ = FALSE;
	GTimeSpan _tmp1_;
	span = (GTimeSpan) 0;
	_tmp0_ = deja_dup_in_testing_mode ();
	if (_tmp0_) {
		span = G_TIME_SPAN_MINUTE * 2;
	} else {
		span = G_TIME_SPAN_DAY * 30;
	}
	_tmp1_ = span;
	result = (gint) (_tmp1_ / G_TIME_SPAN_SECOND);
	return result;
}


gboolean deja_dup_has_seen_settings (void) {
	gboolean result = FALSE;
	DejaDupSimpleSettings* _tmp0_ = NULL;
	DejaDupSimpleSettings* settings;
	gboolean _tmp1_ = FALSE;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	gboolean _tmp4_;
	gboolean _tmp7_;
	_tmp0_ = deja_dup_get_settings (NULL);
	settings = _tmp0_;
	_tmp2_ = deja_dup_last_run_date (DEJA_DUP_TIMESTAMP_TYPE_NONE);
	_tmp3_ = _tmp2_;
	_tmp4_ = g_strcmp0 (_tmp3_, "") != 0;
	_g_free0 (_tmp3_);
	if (_tmp4_) {
		_tmp1_ = TRUE;
	} else {
		DejaDupSimpleSettings* _tmp5_;
		gboolean _tmp6_ = FALSE;
		_tmp5_ = settings;
		_tmp6_ = g_settings_get_boolean ((GSettings*) _tmp5_, DEJA_DUP_WELCOMED_KEY);
		_tmp1_ = _tmp6_;
	}
	_tmp7_ = _tmp1_;
	result = _tmp7_;
	_g_object_unref0 (settings);
	return result;
}


void deja_dup_make_prompt_check (void) {
	DejaDupSimpleSettings* _tmp0_ = NULL;
	DejaDupSimpleSettings* settings;
	DejaDupSimpleSettings* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* prompt;
	const gchar* _tmp3_;
	GTimeVal last_run_tval = {0};
	const gchar* _tmp6_;
	gboolean _tmp7_ = FALSE;
	GTimeVal _tmp8_;
	GDateTime* _tmp9_;
	GDateTime* last_run;
	GDateTime* _tmp10_;
	gint _tmp11_ = 0;
	GDateTime* _tmp12_ = NULL;
	GDateTime* _tmp13_;
	GDateTime* now;
	GDateTime* _tmp14_;
	GDateTime* _tmp15_;
	gint _tmp16_ = 0;
	_tmp0_ = deja_dup_get_settings (NULL);
	settings = _tmp0_;
	_tmp1_ = settings;
	_tmp2_ = g_settings_get_string ((GSettings*) _tmp1_, DEJA_DUP_PROMPT_CHECK_KEY);
	prompt = _tmp2_;
	_tmp3_ = prompt;
	if (g_strcmp0 (_tmp3_, "disabled") == 0) {
		_g_free0 (prompt);
		_g_object_unref0 (settings);
		return;
	} else {
		const gchar* _tmp4_;
		_tmp4_ = prompt;
		if (g_strcmp0 (_tmp4_, "") == 0) {
			deja_dup_update_prompt_time (FALSE);
			_g_free0 (prompt);
			_g_object_unref0 (settings);
			return;
		} else {
			gboolean _tmp5_ = FALSE;
			_tmp5_ = deja_dup_has_seen_settings ();
			if (_tmp5_) {
				_g_free0 (prompt);
				_g_object_unref0 (settings);
				return;
			}
		}
	}
	g_get_current_time (&last_run_tval);
	_tmp6_ = prompt;
	_tmp7_ = g_time_val_from_iso8601 (_tmp6_, &last_run_tval);
	if (!_tmp7_) {
		_g_free0 (prompt);
		_g_object_unref0 (settings);
		return;
	}
	_tmp8_ = last_run_tval;
	_tmp9_ = g_date_time_new_from_timeval_local (&_tmp8_);
	last_run = _tmp9_;
	_tmp10_ = last_run;
	_tmp11_ = deja_dup_get_prompt_delay ();
	_tmp12_ = g_date_time_add_seconds (_tmp10_, (gdouble) _tmp11_);
	_g_date_time_unref0 (last_run);
	last_run = _tmp12_;
	_tmp13_ = g_date_time_new_now_local ();
	now = _tmp13_;
	_tmp14_ = last_run;
	_tmp15_ = now;
	_tmp16_ = g_date_time_compare (_tmp14_, _tmp15_);
	if (_tmp16_ <= 0) {
		deja_dup_run_deja_dup ("--prompt", NULL, NULL);
	}
	_g_date_time_unref0 (now);
	_g_date_time_unref0 (last_run);
	_g_free0 (prompt);
	_g_object_unref0 (settings);
}


void deja_dup_update_time_key (const gchar* key, gboolean cancel) {
	DejaDupSimpleSettings* _tmp0_ = NULL;
	DejaDupSimpleSettings* settings;
	DejaDupSimpleSettings* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	gboolean _tmp5_;
	gchar* cur_time_str = NULL;
	gboolean _tmp6_;
	DejaDupSimpleSettings* _tmp9_;
	const gchar* _tmp10_;
	const gchar* _tmp11_;
	g_return_if_fail (key != NULL);
	_tmp0_ = deja_dup_get_settings (NULL);
	settings = _tmp0_;
	_tmp1_ = settings;
	_tmp2_ = key;
	_tmp3_ = g_settings_get_string ((GSettings*) _tmp1_, _tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_strcmp0 (_tmp4_, "disabled") == 0;
	_g_free0 (_tmp4_);
	if (_tmp5_) {
		_g_object_unref0 (settings);
		return;
	}
	_tmp6_ = cancel;
	if (_tmp6_) {
		gchar* _tmp7_;
		_tmp7_ = g_strdup ("disabled");
		_g_free0 (cur_time_str);
		cur_time_str = _tmp7_;
	} else {
		GTimeVal cur_time = {0};
		gchar* _tmp8_ = NULL;
		g_get_current_time (&cur_time);
		g_get_current_time (&cur_time);
		_tmp8_ = g_time_val_to_iso8601 (&cur_time);
		_g_free0 (cur_time_str);
		cur_time_str = _tmp8_;
	}
	_tmp9_ = settings;
	_tmp10_ = key;
	_tmp11_ = cur_time_str;
	deja_dup_simple_settings_set_string (_tmp9_, _tmp10_, _tmp11_);
	_g_free0 (cur_time_str);
	_g_object_unref0 (settings);
}


void deja_dup_update_prompt_time (gboolean cancel) {
	gboolean _tmp0_;
	_tmp0_ = cancel;
	deja_dup_update_time_key (DEJA_DUP_PROMPT_CHECK_KEY, _tmp0_);
}


void deja_dup_update_nag_time (gboolean cancel) {
	gboolean _tmp0_;
	_tmp0_ = cancel;
	deja_dup_update_time_key (DEJA_DUP_NAG_CHECK_KEY, _tmp0_);
}


gint deja_dup_get_nag_delay (void) {
	gint result = 0;
	GTimeSpan span;
	gboolean _tmp0_ = FALSE;
	GTimeSpan _tmp1_;
	span = (GTimeSpan) 0;
	_tmp0_ = deja_dup_in_testing_mode ();
	if (_tmp0_) {
		span = G_TIME_SPAN_MINUTE * 2;
	} else {
		span = (G_TIME_SPAN_DAY * 30) * 2;
	}
	_tmp1_ = span;
	result = (gint) (_tmp1_ / G_TIME_SPAN_SECOND);
	return result;
}


gboolean deja_dup_is_nag_time (void) {
	gboolean result = FALSE;
	DejaDupSimpleSettings* _tmp0_ = NULL;
	DejaDupSimpleSettings* settings;
	DejaDupSimpleSettings* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* nag;
	gchar* _tmp3_ = NULL;
	gchar* last_run_string;
	gboolean _tmp4_ = FALSE;
	const gchar* _tmp5_;
	gboolean _tmp7_;
	GTimeVal last_check_tval = {0};
	const gchar* _tmp9_;
	gboolean _tmp10_ = FALSE;
	GTimeVal _tmp11_;
	GDateTime* _tmp12_;
	GDateTime* last_check;
	GDateTime* _tmp13_;
	gint _tmp14_ = 0;
	GDateTime* _tmp15_ = NULL;
	GDateTime* _tmp16_;
	GDateTime* now;
	GDateTime* _tmp17_;
	GDateTime* _tmp18_;
	gint _tmp19_ = 0;
	_tmp0_ = deja_dup_get_settings (NULL);
	settings = _tmp0_;
	_tmp1_ = settings;
	_tmp2_ = g_settings_get_string ((GSettings*) _tmp1_, DEJA_DUP_NAG_CHECK_KEY);
	nag = _tmp2_;
	_tmp3_ = deja_dup_last_run_date (DEJA_DUP_TIMESTAMP_TYPE_BACKUP);
	last_run_string = _tmp3_;
	_tmp5_ = nag;
	if (g_strcmp0 (_tmp5_, "disabled") == 0) {
		_tmp4_ = TRUE;
	} else {
		const gchar* _tmp6_;
		_tmp6_ = last_run_string;
		_tmp4_ = g_strcmp0 (_tmp6_, "") == 0;
	}
	_tmp7_ = _tmp4_;
	if (_tmp7_) {
		result = FALSE;
		_g_free0 (last_run_string);
		_g_free0 (nag);
		_g_object_unref0 (settings);
		return result;
	} else {
		const gchar* _tmp8_;
		_tmp8_ = nag;
		if (g_strcmp0 (_tmp8_, "") == 0) {
			deja_dup_update_nag_time (FALSE);
			result = FALSE;
			_g_free0 (last_run_string);
			_g_free0 (nag);
			_g_object_unref0 (settings);
			return result;
		}
	}
	g_get_current_time (&last_check_tval);
	_tmp9_ = nag;
	_tmp10_ = g_time_val_from_iso8601 (_tmp9_, &last_check_tval);
	if (!_tmp10_) {
		result = FALSE;
		_g_free0 (last_run_string);
		_g_free0 (nag);
		_g_object_unref0 (settings);
		return result;
	}
	_tmp11_ = last_check_tval;
	_tmp12_ = g_date_time_new_from_timeval_local (&_tmp11_);
	last_check = _tmp12_;
	_tmp13_ = last_check;
	_tmp14_ = deja_dup_get_nag_delay ();
	_tmp15_ = g_date_time_add_seconds (_tmp13_, (gdouble) _tmp14_);
	_g_date_time_unref0 (last_check);
	last_check = _tmp15_;
	_tmp16_ = g_date_time_new_now_local ();
	now = _tmp16_;
	_tmp17_ = last_check;
	_tmp18_ = now;
	_tmp19_ = g_date_time_compare (_tmp17_, _tmp18_);
	result = _tmp19_ <= 0;
	_g_date_time_unref0 (now);
	_g_date_time_unref0 (last_check);
	_g_free0 (last_run_string);
	_g_free0 (nag);
	_g_object_unref0 (settings);
	return result;
}


static gboolean string_contains (const gchar* self, const gchar* needle) {
	gboolean result = FALSE;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = needle;
	_tmp1_ = strstr ((gchar*) self, (gchar*) _tmp0_);
	result = _tmp1_ != NULL;
	return result;
}


static gchar* string_replace (const gchar* self, const gchar* old, const gchar* replacement) {
	gchar* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	{
		const gchar* _tmp0_;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_;
		GRegex* _tmp3_;
		GRegex* _tmp4_;
		GRegex* regex;
		GRegex* _tmp5_;
		const gchar* _tmp6_;
		gchar* _tmp7_ = NULL;
		gchar* _tmp8_;
		_tmp0_ = old;
		_tmp1_ = g_regex_escape_string (_tmp0_, -1);
		_tmp2_ = _tmp1_;
		_tmp3_ = g_regex_new (_tmp2_, 0, 0, &_inner_error_);
		_tmp4_ = _tmp3_;
		_g_free0 (_tmp2_);
		regex = _tmp4_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch15_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp5_ = regex;
		_tmp6_ = replacement;
		_tmp7_ = g_regex_replace_literal (_tmp5_, self, (gssize) (-1), 0, _tmp6_, 0, &_inner_error_);
		_tmp8_ = _tmp7_;
		if (_inner_error_ != NULL) {
			_g_regex_unref0 (regex);
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch15_g_regex_error;
			}
			_g_regex_unref0 (regex);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		result = _tmp8_;
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally15;
	__catch15_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally15:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


static glong string_strnlen (gchar* str, glong maxlen) {
	glong result = 0L;
	gchar* _tmp0_;
	glong _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* end;
	gchar* _tmp3_;
	_tmp0_ = str;
	_tmp1_ = maxlen;
	_tmp2_ = memchr (_tmp0_, 0, (gsize) _tmp1_);
	end = _tmp2_;
	_tmp3_ = end;
	if (_tmp3_ == NULL) {
		glong _tmp4_;
		_tmp4_ = maxlen;
		result = _tmp4_;
		return result;
	} else {
		gchar* _tmp5_;
		gchar* _tmp6_;
		_tmp5_ = end;
		_tmp6_ = str;
		result = (glong) (_tmp5_ - _tmp6_);
		return result;
	}
}


static gchar* string_substring (const gchar* self, glong offset, glong len) {
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	glong _tmp1_;
	gboolean _tmp3_;
	glong _tmp9_;
	glong _tmp15_;
	glong _tmp18_;
	glong _tmp19_;
	glong _tmp20_;
	glong _tmp21_;
	glong _tmp22_;
	gchar* _tmp23_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = offset;
	if (_tmp1_ >= ((glong) 0)) {
		glong _tmp2_;
		_tmp2_ = len;
		_tmp0_ = _tmp2_ >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	_tmp3_ = _tmp0_;
	if (_tmp3_) {
		glong _tmp4_;
		glong _tmp5_;
		glong _tmp6_ = 0L;
		_tmp4_ = offset;
		_tmp5_ = len;
		_tmp6_ = string_strnlen ((gchar*) self, _tmp4_ + _tmp5_);
		string_length = _tmp6_;
	} else {
		gint _tmp7_;
		gint _tmp8_;
		_tmp7_ = strlen (self);
		_tmp8_ = _tmp7_;
		string_length = (glong) _tmp8_;
	}
	_tmp9_ = offset;
	if (_tmp9_ < ((glong) 0)) {
		glong _tmp10_;
		glong _tmp11_;
		glong _tmp12_;
		_tmp10_ = string_length;
		_tmp11_ = offset;
		offset = _tmp10_ + _tmp11_;
		_tmp12_ = offset;
		g_return_val_if_fail (_tmp12_ >= ((glong) 0), NULL);
	} else {
		glong _tmp13_;
		glong _tmp14_;
		_tmp13_ = offset;
		_tmp14_ = string_length;
		g_return_val_if_fail (_tmp13_ <= _tmp14_, NULL);
	}
	_tmp15_ = len;
	if (_tmp15_ < ((glong) 0)) {
		glong _tmp16_;
		glong _tmp17_;
		_tmp16_ = string_length;
		_tmp17_ = offset;
		len = _tmp16_ - _tmp17_;
	}
	_tmp18_ = offset;
	_tmp19_ = len;
	_tmp20_ = string_length;
	g_return_val_if_fail ((_tmp18_ + _tmp19_) <= _tmp20_, NULL);
	_tmp21_ = offset;
	_tmp22_ = len;
	_tmp23_ = g_strndup (((gchar*) self) + _tmp21_, (gsize) _tmp22_);
	result = _tmp23_;
	return result;
}


gchar* deja_dup_get_folder_key (DejaDupSimpleSettings* settings, const gchar* key) {
	gchar* result = NULL;
	DejaDupSimpleSettings* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* folder;
	const gchar* _tmp3_;
	gboolean _tmp4_ = FALSE;
	const gchar* _tmp11_;
	gboolean _tmp12_ = FALSE;
	g_return_val_if_fail (settings != NULL, NULL);
	g_return_val_if_fail (key != NULL, NULL);
	_tmp0_ = settings;
	_tmp1_ = key;
	_tmp2_ = g_settings_get_string ((GSettings*) _tmp0_, _tmp1_);
	folder = _tmp2_;
	_tmp3_ = folder;
	_tmp4_ = string_contains (_tmp3_, "$HOSTNAME");
	if (_tmp4_) {
		const gchar* _tmp5_;
		const gchar* _tmp6_ = NULL;
		gchar* _tmp7_ = NULL;
		DejaDupSimpleSettings* _tmp8_;
		const gchar* _tmp9_;
		const gchar* _tmp10_;
		_tmp5_ = folder;
		_tmp6_ = g_get_host_name ();
		_tmp7_ = string_replace (_tmp5_, "$HOSTNAME", _tmp6_);
		_g_free0 (folder);
		folder = _tmp7_;
		_tmp8_ = settings;
		_tmp9_ = key;
		_tmp10_ = folder;
		deja_dup_simple_settings_set_string (_tmp8_, _tmp9_, _tmp10_);
	}
	_tmp11_ = folder;
	_tmp12_ = g_str_has_prefix (_tmp11_, "/");
	if (_tmp12_) {
		const gchar* _tmp13_;
		gchar* _tmp14_ = NULL;
		_tmp13_ = folder;
		_tmp14_ = string_substring (_tmp13_, (glong) 1, (glong) (-1));
		_g_free0 (folder);
		folder = _tmp14_;
	}
	result = folder;
	return result;
}


void deja_dup_set_settings_read_only (gboolean ro) {
	gboolean _tmp0_;
	gboolean _tmp1_;
	_tmp0_ = ro;
	deja_dup_settings_read_only = _tmp0_;
	_tmp1_ = deja_dup_settings_read_only;
	if (_tmp1_) {
		GHashFunc _tmp2_;
		GEqualFunc _tmp3_;
		GDestroyNotify _tmp4_;
		GDestroyNotify _tmp5_;
		GHashTable* _tmp6_;
		_tmp2_ = g_str_hash;
		_tmp3_ = g_str_equal;
		_tmp4_ = g_free;
		_tmp5_ = g_object_unref;
		_tmp6_ = g_hash_table_new_full (_tmp2_, _tmp3_, _tmp4_, _tmp5_);
		_g_hash_table_unref0 (deja_dup_settings_table);
		deja_dup_settings_table = _tmp6_;
	} else {
		_g_hash_table_unref0 (deja_dup_settings_table);
		deja_dup_settings_table = NULL;
	}
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


DejaDupSimpleSettings* deja_dup_get_settings (const gchar* subdir) {
	DejaDupSimpleSettings* result = NULL;
	gchar* _tmp0_;
	gchar* schema;
	gboolean _tmp1_ = FALSE;
	const gchar* _tmp2_;
	gboolean _tmp4_;
	DejaDupSimpleSettings* rv = NULL;
	gboolean _tmp10_;
	_tmp0_ = g_strdup ("org.gnome.DejaDup");
	schema = _tmp0_;
	_tmp2_ = subdir;
	if (_tmp2_ != NULL) {
		const gchar* _tmp3_;
		_tmp3_ = subdir;
		_tmp1_ = g_strcmp0 (_tmp3_, "") != 0;
	} else {
		_tmp1_ = FALSE;
	}
	_tmp4_ = _tmp1_;
	if (_tmp4_) {
		const gchar* _tmp5_;
		const gchar* _tmp6_;
		gchar* _tmp7_;
		gchar* _tmp8_;
		gchar* _tmp9_;
		_tmp5_ = schema;
		_tmp6_ = subdir;
		_tmp7_ = g_strconcat (".", _tmp6_, NULL);
		_tmp8_ = _tmp7_;
		_tmp9_ = g_strconcat (_tmp5_, _tmp8_, NULL);
		_g_free0 (schema);
		schema = _tmp9_;
		_g_free0 (_tmp8_);
	}
	_tmp10_ = deja_dup_settings_read_only;
	if (_tmp10_) {
		GHashTable* _tmp11_;
		const gchar* _tmp12_;
		gconstpointer _tmp13_ = NULL;
		DejaDupSimpleSettings* _tmp14_;
		DejaDupSimpleSettings* _tmp15_;
		_tmp11_ = deja_dup_settings_table;
		_tmp12_ = schema;
		_tmp13_ = g_hash_table_lookup (_tmp11_, _tmp12_);
		_tmp14_ = _g_object_ref0 ((DejaDupSimpleSettings*) _tmp13_);
		_g_object_unref0 (rv);
		rv = _tmp14_;
		_tmp15_ = rv;
		if (_tmp15_ == NULL) {
			const gchar* _tmp16_;
			DejaDupSimpleSettings* _tmp17_;
			DejaDupSimpleSettings* _tmp18_;
			GHashTable* _tmp19_;
			const gchar* _tmp20_;
			gchar* _tmp21_;
			DejaDupSimpleSettings* _tmp22_;
			DejaDupSimpleSettings* _tmp23_;
			_tmp16_ = schema;
			_tmp17_ = deja_dup_simple_settings_new (_tmp16_, TRUE);
			_g_object_unref0 (rv);
			rv = _tmp17_;
			_tmp18_ = rv;
			g_settings_delay ((GSettings*) _tmp18_);
			_tmp19_ = deja_dup_settings_table;
			_tmp20_ = schema;
			_tmp21_ = g_strdup (_tmp20_);
			_tmp22_ = rv;
			_tmp23_ = _g_object_ref0 (_tmp22_);
			g_hash_table_insert (_tmp19_, _tmp21_, _tmp23_);
		}
	} else {
		const gchar* _tmp24_;
		DejaDupSimpleSettings* _tmp25_;
		_tmp24_ = schema;
		_tmp25_ = deja_dup_simple_settings_new (_tmp24_, FALSE);
		_g_object_unref0 (rv);
		rv = _tmp25_;
	}
	result = rv;
	_g_free0 (schema);
	return result;
}


DejaDupSimpleSettings* deja_dup_get_app_settings (const gchar* ske, const gchar* subdir) {
	DejaDupSimpleSettings* result = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* schema;
	gboolean _tmp2_ = FALSE;
	const gchar* _tmp3_;
	gboolean _tmp5_;
	DejaDupSimpleSettings* rv = NULL;
	gboolean _tmp11_;
	g_return_val_if_fail (ske != NULL, NULL);
	_tmp0_ = ske;
	_tmp1_ = g_strdup (_tmp0_);
	schema = _tmp1_;
	_tmp3_ = subdir;
	if (_tmp3_ != NULL) {
		const gchar* _tmp4_;
		_tmp4_ = subdir;
		_tmp2_ = g_strcmp0 (_tmp4_, "") != 0;
	} else {
		_tmp2_ = FALSE;
	}
	_tmp5_ = _tmp2_;
	if (_tmp5_) {
		const gchar* _tmp6_;
		const gchar* _tmp7_;
		gchar* _tmp8_;
		gchar* _tmp9_;
		gchar* _tmp10_;
		_tmp6_ = schema;
		_tmp7_ = subdir;
		_tmp8_ = g_strconcat (".", _tmp7_, NULL);
		_tmp9_ = _tmp8_;
		_tmp10_ = g_strconcat (_tmp6_, _tmp9_, NULL);
		_g_free0 (schema);
		schema = _tmp10_;
		_g_free0 (_tmp9_);
	}
	_tmp11_ = deja_dup_settings_read_only;
	if (_tmp11_) {
		GHashTable* _tmp12_;
		const gchar* _tmp13_;
		gconstpointer _tmp14_ = NULL;
		DejaDupSimpleSettings* _tmp15_;
		DejaDupSimpleSettings* _tmp16_;
		_tmp12_ = deja_dup_settings_table;
		_tmp13_ = schema;
		_tmp14_ = g_hash_table_lookup (_tmp12_, _tmp13_);
		_tmp15_ = _g_object_ref0 ((DejaDupSimpleSettings*) _tmp14_);
		_g_object_unref0 (rv);
		rv = _tmp15_;
		_tmp16_ = rv;
		if (_tmp16_ == NULL) {
			const gchar* _tmp17_;
			DejaDupSimpleSettings* _tmp18_;
			DejaDupSimpleSettings* _tmp19_;
			GHashTable* _tmp20_;
			const gchar* _tmp21_;
			gchar* _tmp22_;
			DejaDupSimpleSettings* _tmp23_;
			DejaDupSimpleSettings* _tmp24_;
			_tmp17_ = schema;
			_tmp18_ = deja_dup_simple_settings_new (_tmp17_, TRUE);
			_g_object_unref0 (rv);
			rv = _tmp18_;
			_tmp19_ = rv;
			g_settings_delay ((GSettings*) _tmp19_);
			_tmp20_ = deja_dup_settings_table;
			_tmp21_ = schema;
			_tmp22_ = g_strdup (_tmp21_);
			_tmp23_ = rv;
			_tmp24_ = _g_object_ref0 (_tmp23_);
			g_hash_table_insert (_tmp20_, _tmp22_, _tmp24_);
		}
	} else {
		const gchar* _tmp25_;
		DejaDupSimpleSettings* _tmp26_;
		_tmp25_ = schema;
		_tmp26_ = deja_dup_simple_settings_new (_tmp25_, FALSE);
		_g_object_unref0 (rv);
		rv = _tmp26_;
	}
	result = rv;
	_g_free0 (schema);
	return result;
}


static gchar string_get (const gchar* self, glong index) {
	gchar result = '\0';
	glong _tmp0_;
	gchar _tmp1_;
	g_return_val_if_fail (self != NULL, '\0');
	_tmp0_ = index;
	_tmp1_ = ((gchar*) self)[_tmp0_];
	result = _tmp1_;
	return result;
}


void deja_dup_convert_ssh_to_file (void) {
	DejaDupSimpleSettings* _tmp0_ = NULL;
	DejaDupSimpleSettings* settings;
	DejaDupSimpleSettings* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* backend;
	const gchar* _tmp3_;
	_tmp0_ = deja_dup_get_settings (NULL);
	settings = _tmp0_;
	_tmp1_ = settings;
	_tmp2_ = g_settings_get_string ((GSettings*) _tmp1_, DEJA_DUP_BACKEND_KEY);
	backend = _tmp2_;
	_tmp3_ = backend;
	if (g_strcmp0 (_tmp3_, "ssh") == 0) {
		DejaDupSimpleSettings* _tmp4_;
		DejaDupSimpleSettings* _tmp5_ = NULL;
		DejaDupSimpleSettings* ssh_settings;
		DejaDupSimpleSettings* _tmp6_;
		gchar* _tmp7_ = NULL;
		gchar* server;
		gboolean _tmp8_ = FALSE;
		const gchar* _tmp9_;
		gboolean _tmp11_;
		_tmp4_ = settings;
		deja_dup_simple_settings_set_string (_tmp4_, DEJA_DUP_BACKEND_KEY, "file");
		_tmp5_ = deja_dup_get_settings ("SSH");
		ssh_settings = _tmp5_;
		_tmp6_ = ssh_settings;
		_tmp7_ = g_settings_get_string ((GSettings*) _tmp6_, DEJA_DUP_SSH_SERVER_KEY);
		server = _tmp7_;
		_tmp9_ = server;
		if (_tmp9_ != NULL) {
			const gchar* _tmp10_;
			_tmp10_ = server;
			_tmp8_ = g_strcmp0 (_tmp10_, "") != 0;
		} else {
			_tmp8_ = FALSE;
		}
		_tmp11_ = _tmp8_;
		if (_tmp11_) {
			DejaDupSimpleSettings* _tmp12_;
			gchar* _tmp13_ = NULL;
			gchar* username;
			DejaDupSimpleSettings* _tmp14_;
			gint _tmp15_ = 0;
			gint port;
			DejaDupSimpleSettings* _tmp16_;
			gchar* _tmp17_ = NULL;
			gchar* directory;
			gchar* _tmp18_;
			gchar* gio_uri;
			gboolean _tmp19_ = FALSE;
			const gchar* _tmp20_;
			gboolean _tmp22_;
			const gchar* _tmp28_;
			const gchar* _tmp29_;
			gchar* _tmp30_;
			gboolean _tmp31_ = FALSE;
			gint _tmp32_;
			gboolean _tmp34_;
			gboolean _tmp42_ = FALSE;
			const gchar* _tmp43_;
			gboolean _tmp45_;
			DejaDupSimpleSettings* _tmp58_ = NULL;
			DejaDupSimpleSettings* file_settings;
			DejaDupSimpleSettings* _tmp59_;
			const gchar* _tmp60_;
			_tmp12_ = ssh_settings;
			_tmp13_ = g_settings_get_string ((GSettings*) _tmp12_, DEJA_DUP_SSH_USERNAME_KEY);
			username = _tmp13_;
			_tmp14_ = ssh_settings;
			_tmp15_ = g_settings_get_int ((GSettings*) _tmp14_, DEJA_DUP_SSH_PORT_KEY);
			port = _tmp15_;
			_tmp16_ = ssh_settings;
			_tmp17_ = g_settings_get_string ((GSettings*) _tmp16_, DEJA_DUP_SSH_DIRECTORY_KEY);
			directory = _tmp17_;
			_tmp18_ = g_strdup ("ssh://");
			gio_uri = _tmp18_;
			_tmp20_ = username;
			if (_tmp20_ != NULL) {
				const gchar* _tmp21_;
				_tmp21_ = username;
				_tmp19_ = g_strcmp0 (_tmp21_, "") != 0;
			} else {
				_tmp19_ = FALSE;
			}
			_tmp22_ = _tmp19_;
			if (_tmp22_) {
				const gchar* _tmp23_;
				const gchar* _tmp24_;
				gchar* _tmp25_;
				gchar* _tmp26_;
				gchar* _tmp27_;
				_tmp23_ = gio_uri;
				_tmp24_ = username;
				_tmp25_ = g_strconcat (_tmp24_, "@", NULL);
				_tmp26_ = _tmp25_;
				_tmp27_ = g_strconcat (_tmp23_, _tmp26_, NULL);
				_g_free0 (gio_uri);
				gio_uri = _tmp27_;
				_g_free0 (_tmp26_);
			}
			_tmp28_ = gio_uri;
			_tmp29_ = server;
			_tmp30_ = g_strconcat (_tmp28_, _tmp29_, NULL);
			_g_free0 (gio_uri);
			gio_uri = _tmp30_;
			_tmp32_ = port;
			if (_tmp32_ > 0) {
				gint _tmp33_;
				_tmp33_ = port;
				_tmp31_ = _tmp33_ != 22;
			} else {
				_tmp31_ = FALSE;
			}
			_tmp34_ = _tmp31_;
			if (_tmp34_) {
				const gchar* _tmp35_;
				gint _tmp36_;
				gchar* _tmp37_ = NULL;
				gchar* _tmp38_;
				gchar* _tmp39_;
				gchar* _tmp40_;
				gchar* _tmp41_;
				_tmp35_ = gio_uri;
				_tmp36_ = port;
				_tmp37_ = g_strdup_printf ("%i", _tmp36_);
				_tmp38_ = _tmp37_;
				_tmp39_ = g_strconcat (":", _tmp38_, NULL);
				_tmp40_ = _tmp39_;
				_tmp41_ = g_strconcat (_tmp35_, _tmp40_, NULL);
				_g_free0 (gio_uri);
				gio_uri = _tmp41_;
				_g_free0 (_tmp40_);
				_g_free0 (_tmp38_);
			}
			_tmp43_ = directory;
			if (_tmp43_ == NULL) {
				_tmp42_ = TRUE;
			} else {
				const gchar* _tmp44_;
				_tmp44_ = directory;
				_tmp42_ = g_strcmp0 (_tmp44_, "") == 0;
			}
			_tmp45_ = _tmp42_;
			if (_tmp45_) {
				const gchar* _tmp46_;
				gchar* _tmp47_;
				_tmp46_ = gio_uri;
				_tmp47_ = g_strconcat (_tmp46_, "/", NULL);
				_g_free0 (gio_uri);
				gio_uri = _tmp47_;
			} else {
				const gchar* _tmp48_;
				gchar _tmp49_ = '\0';
				_tmp48_ = directory;
				_tmp49_ = string_get (_tmp48_, (glong) 0);
				if (_tmp49_ != '/') {
					const gchar* _tmp50_;
					const gchar* _tmp51_;
					gchar* _tmp52_;
					gchar* _tmp53_;
					gchar* _tmp54_;
					_tmp50_ = gio_uri;
					_tmp51_ = directory;
					_tmp52_ = g_strconcat ("/", _tmp51_, NULL);
					_tmp53_ = _tmp52_;
					_tmp54_ = g_strconcat (_tmp50_, _tmp53_, NULL);
					_g_free0 (gio_uri);
					gio_uri = _tmp54_;
					_g_free0 (_tmp53_);
				} else {
					const gchar* _tmp55_;
					const gchar* _tmp56_;
					gchar* _tmp57_;
					_tmp55_ = gio_uri;
					_tmp56_ = directory;
					_tmp57_ = g_strconcat (_tmp55_, _tmp56_, NULL);
					_g_free0 (gio_uri);
					gio_uri = _tmp57_;
				}
			}
			_tmp58_ = deja_dup_get_settings (DEJA_DUP_FILE_ROOT);
			file_settings = _tmp58_;
			_tmp59_ = file_settings;
			_tmp60_ = gio_uri;
			deja_dup_simple_settings_set_string (_tmp59_, DEJA_DUP_FILE_PATH_KEY, _tmp60_);
			_g_object_unref0 (file_settings);
			_g_free0 (gio_uri);
			_g_free0 (directory);
			_g_free0 (username);
		}
		_g_free0 (server);
		_g_object_unref0 (ssh_settings);
	}
	_g_free0 (backend);
	_g_object_unref0 (settings);
}


void deja_dup_convert_s3_folder_to_hostname (void) {
	DejaDupSimpleSettings* _tmp0_ = NULL;
	DejaDupSimpleSettings* settings;
	DejaDupSimpleSettings* _tmp1_ = NULL;
	DejaDupSimpleSettings* s3_settings;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	DejaDupSimpleSettings* _tmp4_;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_;
	gboolean _tmp7_;
	gboolean _tmp11_;
	gboolean _tmp20_;
	_tmp0_ = deja_dup_get_settings (NULL);
	settings = _tmp0_;
	_tmp1_ = deja_dup_get_settings (DEJA_DUP_S3_ROOT);
	s3_settings = _tmp1_;
	_tmp4_ = s3_settings;
	_tmp5_ = g_settings_get_string ((GSettings*) _tmp4_, DEJA_DUP_S3_FOLDER_KEY);
	_tmp6_ = _tmp5_;
	_tmp7_ = g_strcmp0 (_tmp6_, "") == 0;
	_g_free0 (_tmp6_);
	if (_tmp7_) {
		_tmp3_ = TRUE;
	} else {
		DejaDupSimpleSettings* _tmp8_;
		gchar* _tmp9_ = NULL;
		gchar* _tmp10_;
		_tmp8_ = s3_settings;
		_tmp9_ = g_settings_get_string ((GSettings*) _tmp8_, DEJA_DUP_S3_FOLDER_KEY);
		_tmp10_ = _tmp9_;
		_tmp3_ = g_strcmp0 (_tmp10_, "/") == 0;
		_g_free0 (_tmp10_);
	}
	_tmp11_ = _tmp3_;
	if (_tmp11_) {
		gboolean _tmp12_ = FALSE;
		gchar* _tmp13_ = NULL;
		gchar* _tmp14_;
		gboolean _tmp15_;
		gboolean _tmp19_;
		_tmp13_ = deja_dup_backend_get_default_type ();
		_tmp14_ = _tmp13_;
		_tmp15_ = g_strcmp0 (_tmp14_, "s3") != 0;
		_g_free0 (_tmp14_);
		if (_tmp15_) {
			_tmp12_ = TRUE;
		} else {
			DejaDupSimpleSettings* _tmp16_;
			gchar* _tmp17_ = NULL;
			gchar* _tmp18_;
			_tmp16_ = settings;
			_tmp17_ = g_settings_get_string ((GSettings*) _tmp16_, DEJA_DUP_LAST_RUN_KEY);
			_tmp18_ = _tmp17_;
			_tmp12_ = g_strcmp0 (_tmp18_, "") == 0;
			_g_free0 (_tmp18_);
		}
		_tmp19_ = _tmp12_;
		_tmp2_ = _tmp19_;
	} else {
		_tmp2_ = FALSE;
	}
	_tmp20_ = _tmp2_;
	if (_tmp20_) {
		DejaDupSimpleSettings* _tmp21_;
		_tmp21_ = s3_settings;
		deja_dup_simple_settings_set_string (_tmp21_, DEJA_DUP_S3_FOLDER_KEY, "$HOSTNAME");
	}
	_g_object_unref0 (s3_settings);
	_g_object_unref0 (settings);
}


static PeasPluginInfo* _vala_PeasPluginInfo_copy (PeasPluginInfo* self) {
	return g_boxed_copy (peas_plugin_info_get_type (), self);
}


static gpointer __vala_PeasPluginInfo_copy0 (gpointer self) {
	return self ? _vala_PeasPluginInfo_copy (self) : NULL;
}


static void _vala_PeasPluginInfo_free (PeasPluginInfo* self) {
	g_boxed_free (peas_plugin_info_get_type (), self);
}


void deja_dup_initialize_tool_plugin (GError** error) {
	PeasEngine* _tmp0_;
	PeasEngine* engine;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* search_path;
	gboolean _tmp3_ = FALSE;
	const gchar* _tmp4_;
	gboolean _tmp6_;
	PeasEngine* _tmp8_;
	const gchar* _tmp9_;
	PeasEngine* _tmp10_;
	PeasPluginInfo* _tmp11_ = NULL;
	PeasPluginInfo* _tmp12_;
	PeasPluginInfo* info;
	PeasPluginInfo* _tmp13_;
	PeasEngine* _tmp20_;
	PeasPluginInfo* _tmp21_;
	gboolean _tmp22_ = FALSE;
	PeasEngine* _tmp25_;
	PeasExtensionSet* _tmp26_;
	PeasExtensionSet* extset;
	PeasPluginInfo* _tmp27_;
	PeasExtension* _tmp28_ = NULL;
	PeasExtension* _tmp29_;
	PeasExtension* ext;
	DejaDupToolPlugin* _tmp30_;
	DejaDupToolPlugin* _tmp31_;
	DejaDupToolPlugin* _tmp34_;
	GError * _inner_error_ = NULL;
	_tmp0_ = peas_engine_new ();
	engine = _tmp0_;
	_tmp1_ = g_getenv ("DEJA_DUP_TOOLS_PATH");
	_tmp2_ = g_strdup (_tmp1_);
	search_path = _tmp2_;
	_tmp4_ = search_path;
	if (_tmp4_ == NULL) {
		_tmp3_ = TRUE;
	} else {
		const gchar* _tmp5_;
		_tmp5_ = search_path;
		_tmp3_ = g_strcmp0 (_tmp5_, "") == 0;
	}
	_tmp6_ = _tmp3_;
	if (_tmp6_) {
		gchar* _tmp7_ = NULL;
		_tmp7_ = g_build_filename (PKG_LIBEXEC_DIR, "tools", NULL);
		_g_free0 (search_path);
		search_path = _tmp7_;
	}
	_tmp8_ = engine;
	_tmp9_ = search_path;
	peas_engine_add_search_path (_tmp8_, _tmp9_, NULL);
	_tmp10_ = engine;
	_tmp11_ = peas_engine_get_plugin_info (_tmp10_, "libduplicity.so");
	_tmp12_ = __vala_PeasPluginInfo_copy0 (_tmp11_);
	info = _tmp12_;
	_tmp13_ = info;
	if (_tmp13_ == NULL) {
		const gchar* _tmp14_ = NULL;
		const gchar* _tmp15_;
		gchar* _tmp16_ = NULL;
		gchar* _tmp17_;
		GError* _tmp18_;
		GError* _tmp19_;
		_tmp14_ = _ ("Could not find backup tool in %s.  Your installation is incomplete.");
		_tmp15_ = search_path;
		_tmp16_ = g_strdup_printf (_tmp14_, _tmp15_);
		_tmp17_ = _tmp16_;
		_tmp18_ = g_error_new_literal (G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED, _tmp17_);
		_tmp19_ = _tmp18_;
		_g_free0 (_tmp17_);
		_inner_error_ = _tmp19_;
		g_propagate_error (error, _inner_error_);
		__vala_PeasPluginInfo_free0 (info);
		_g_free0 (search_path);
		_g_object_unref0 (engine);
		return;
	}
	_tmp20_ = engine;
	_tmp21_ = info;
	_tmp22_ = peas_engine_load_plugin (_tmp20_, _tmp21_);
	if (!_tmp22_) {
		const gchar* _tmp23_ = NULL;
		GError* _tmp24_;
		_tmp23_ = _ ("Could not load backup tool.  Your installation is incomplete.");
		_tmp24_ = g_error_new_literal (G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED, _tmp23_);
		_inner_error_ = _tmp24_;
		g_propagate_error (error, _inner_error_);
		__vala_PeasPluginInfo_free0 (info);
		_g_free0 (search_path);
		_g_object_unref0 (engine);
		return;
	}
	_tmp25_ = engine;
	_tmp26_ = peas_extension_set_new (_tmp25_, peas_activatable_get_type (), NULL);
	extset = _tmp26_;
	_tmp27_ = info;
	_tmp28_ = peas_extension_set_get_extension (extset, _tmp27_);
	_tmp29_ = _g_object_ref0 (_tmp28_);
	ext = _tmp29_;
	_tmp30_ = _g_object_ref0 (DEJA_DUP_IS_TOOL_PLUGIN (ext) ? ((DejaDupToolPlugin*) ext) : NULL);
	_g_object_unref0 (deja_dup_tool);
	deja_dup_tool = _tmp30_;
	_tmp31_ = deja_dup_tool;
	if (_tmp31_ == NULL) {
		const gchar* _tmp32_ = NULL;
		GError* _tmp33_;
		_tmp32_ = _ ("Backup tool is broken.  Your installation is incomplete.");
		_tmp33_ = g_error_new_literal (G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED, _tmp32_);
		_inner_error_ = _tmp33_;
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (ext);
		_g_object_unref0 (extset);
		__vala_PeasPluginInfo_free0 (info);
		_g_free0 (search_path);
		_g_object_unref0 (engine);
		return;
	}
	_tmp34_ = deja_dup_tool;
	deja_dup_tool_plugin_activate (_tmp34_);
	_g_object_unref0 (ext);
	_g_object_unref0 (extset);
	__vala_PeasPluginInfo_free0 (info);
	_g_free0 (search_path);
	_g_object_unref0 (engine);
}


void deja_dup_initialize_apps_plugin (GError** error) {
	PeasEngine* _tmp0_;
	PeasEngine* engine;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* search_path;
	gboolean _tmp3_ = FALSE;
	const gchar* _tmp4_;
	gboolean _tmp6_;
	PeasEngine* _tmp8_;
	const gchar* _tmp9_;
	PeasEngine* _tmp10_;
	PeasPluginInfo* _tmp11_ = NULL;
	PeasPluginInfo* _tmp12_;
	PeasPluginInfo* info;
	PeasPluginInfo* _tmp13_;
	PeasEngine* _tmp20_;
	PeasPluginInfo* _tmp21_;
	gboolean _tmp22_ = FALSE;
	PeasEngine* _tmp25_;
	PeasExtensionSet* _tmp26_;
	PeasExtensionSet* extset;
	PeasPluginInfo* _tmp27_;
	PeasExtension* _tmp28_ = NULL;
	PeasExtension* _tmp29_;
	PeasExtension* ext;
	PeasExtensionBase* _tmp30_;
	PeasExtensionBase* _tmp31_;
	GError * _inner_error_ = NULL;
	_tmp0_ = peas_engine_new ();
	engine = _tmp0_;
	_tmp1_ = g_getenv ("DEJA_DUP_APPS_PATH");
	_tmp2_ = g_strdup (_tmp1_);
	search_path = _tmp2_;
	_tmp4_ = search_path;
	if (_tmp4_ == NULL) {
		_tmp3_ = TRUE;
	} else {
		const gchar* _tmp5_;
		_tmp5_ = search_path;
		_tmp3_ = g_strcmp0 (_tmp5_, "") == 0;
	}
	_tmp6_ = _tmp3_;
	if (_tmp6_) {
		gchar* _tmp7_ = NULL;
		_tmp7_ = g_build_filename (PKG_LIBEXEC_DIR, "plugins", NULL);
		_g_free0 (search_path);
		search_path = _tmp7_;
	}
	_tmp8_ = engine;
	_tmp9_ = search_path;
	peas_engine_add_search_path (_tmp8_, _tmp9_, NULL);
	_tmp10_ = engine;
	_tmp11_ = peas_engine_get_plugin_info (_tmp10_, "libapps.so");
	_tmp12_ = __vala_PeasPluginInfo_copy0 (_tmp11_);
	info = _tmp12_;
	_tmp13_ = info;
	if (_tmp13_ == NULL) {
		const gchar* _tmp14_ = NULL;
		const gchar* _tmp15_;
		gchar* _tmp16_ = NULL;
		gchar* _tmp17_;
		GError* _tmp18_;
		GError* _tmp19_;
		_tmp14_ = _ ("Could not find apps plugin in %s.  Your installation is incomplete.");
		_tmp15_ = search_path;
		_tmp16_ = g_strdup_printf (_tmp14_, _tmp15_);
		_tmp17_ = _tmp16_;
		_tmp18_ = g_error_new_literal (G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED, _tmp17_);
		_tmp19_ = _tmp18_;
		_g_free0 (_tmp17_);
		_inner_error_ = _tmp19_;
		g_propagate_error (error, _inner_error_);
		__vala_PeasPluginInfo_free0 (info);
		_g_free0 (search_path);
		_g_object_unref0 (engine);
		return;
	}
	_tmp20_ = engine;
	_tmp21_ = info;
	_tmp22_ = peas_engine_load_plugin (_tmp20_, _tmp21_);
	if (!_tmp22_) {
		const gchar* _tmp23_ = NULL;
		GError* _tmp24_;
		_tmp23_ = _ ("Could not load apps plugin.  Your installation is incomplete.");
		_tmp24_ = g_error_new_literal (G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED, _tmp23_);
		_inner_error_ = _tmp24_;
		g_propagate_error (error, _inner_error_);
		__vala_PeasPluginInfo_free0 (info);
		_g_free0 (search_path);
		_g_object_unref0 (engine);
		return;
	}
	_tmp25_ = engine;
	_tmp26_ = peas_extension_set_new (_tmp25_, peas_activatable_get_type (), NULL);
	extset = _tmp26_;
	_tmp27_ = info;
	_tmp28_ = peas_extension_set_get_extension (extset, _tmp27_);
	_tmp29_ = _g_object_ref0 (_tmp28_);
	ext = _tmp29_;
	_tmp30_ = _g_object_ref0 (PEAS_IS_EXTENSION_BASE (ext) ? ((PeasExtensionBase*) ext) : NULL);
	_g_object_unref0 (deja_dup_apps);
	deja_dup_apps = _tmp30_;
	_tmp31_ = deja_dup_apps;
	if (_tmp31_ == NULL) {
		const gchar* _tmp32_ = NULL;
		GError* _tmp33_;
		_tmp32_ = _ ("Apps plugin is broken.  Your installation is incomplete.");
		_tmp33_ = g_error_new_literal (G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED, _tmp32_);
		_inner_error_ = _tmp33_;
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (ext);
		_g_object_unref0 (extset);
		__vala_PeasPluginInfo_free0 (info);
		_g_free0 (search_path);
		_g_object_unref0 (engine);
		return;
	}
	_g_object_unref0 (ext);
	_g_object_unref0 (extset);
	__vala_PeasPluginInfo_free0 (info);
	_g_free0 (search_path);
	_g_object_unref0 (engine);
}


DejaDupToolJob* deja_dup_make_tool_job (GError** error) {
	DejaDupToolJob* result = NULL;
	DejaDupToolPlugin* _tmp0_;
	DejaDupToolPlugin* _tmp1_;
	DejaDupToolJob* _tmp2_ = NULL;
	DejaDupToolJob* _tmp3_;
	GError * _inner_error_ = NULL;
	_tmp0_ = deja_dup_tool;
	if (_tmp0_ == NULL) {
		deja_dup_initialize_tool_plugin (&_inner_error_);
		if (_inner_error_ != NULL) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		}
	}
	_tmp1_ = deja_dup_tool;
	_tmp2_ = deja_dup_tool_plugin_create_job (_tmp1_, &_inner_error_);
	_tmp3_ = _tmp2_;
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		return NULL;
	}
	result = _tmp3_;
	return result;
}


gboolean deja_dup_initialize (gchar** header, gchar** msg) {
	gchar* _vala_header = NULL;
	gchar* _vala_msg = NULL;
	gboolean result = FALSE;
	DejaDupBackend* _tmp10_ = NULL;
	DejaDupBackend* unused_backend;
	GError * _inner_error_ = NULL;
	_g_free0 (_vala_header);
	_vala_header = NULL;
	_g_free0 (_vala_msg);
	_vala_msg = NULL;
	{
		deja_dup_initialize_tool_plugin (&_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch16_g_error;
		}
	}
	goto __finally16;
	__catch16_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp0_ = NULL;
		gchar* _tmp1_;
		GError* _tmp2_;
		const gchar* _tmp3_;
		gchar* _tmp4_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp0_ = _ ("Could not start backup tool");
		_tmp1_ = g_strdup (_tmp0_);
		_g_free0 (_vala_header);
		_vala_header = _tmp1_;
		_tmp2_ = e;
		_tmp3_ = _tmp2_->message;
		_tmp4_ = g_strdup (_tmp3_);
		_g_free0 (_vala_msg);
		_vala_msg = _tmp4_;
		result = FALSE;
		_g_error_free0 (e);
		if (header) {
			*header = _vala_header;
		} else {
			_g_free0 (_vala_header);
		}
		if (msg) {
			*msg = _vala_msg;
		} else {
			_g_free0 (_vala_msg);
		}
		return result;
	}
	__finally16:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	{
		deja_dup_initialize_apps_plugin (&_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch17_g_error;
		}
	}
	goto __finally17;
	__catch17_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp5_ = NULL;
		gchar* _tmp6_;
		GError* _tmp7_;
		const gchar* _tmp8_;
		gchar* _tmp9_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp5_ = _ ("Could not start apps plugin");
		_tmp6_ = g_strdup (_tmp5_);
		_g_free0 (_vala_header);
		_vala_header = _tmp6_;
		_tmp7_ = e;
		_tmp8_ = _tmp7_->message;
		_tmp9_ = g_strdup (_tmp8_);
		_g_free0 (_vala_msg);
		_vala_msg = _tmp9_;
		result = FALSE;
		_g_error_free0 (e);
		if (header) {
			*header = _vala_header;
		} else {
			_g_free0 (_vala_header);
		}
		if (msg) {
			*msg = _vala_msg;
		} else {
			_g_free0 (_vala_msg);
		}
		return result;
	}
	__finally17:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	deja_dup_convert_ssh_to_file ();
	deja_dup_convert_s3_folder_to_hostname ();
	_tmp10_ = deja_dup_backend_get_default ();
	unused_backend = _tmp10_;
	_g_object_unref0 (unused_backend);
	unused_backend = NULL;
	result = TRUE;
	_g_object_unref0 (unused_backend);
	if (header) {
		*header = _vala_header;
	} else {
		_g_free0 (_vala_header);
	}
	if (msg) {
		*msg = _vala_msg;
	} else {
		_g_free0 (_vala_msg);
	}
	return result;
}


void deja_dup_i18n_setup (void) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gchar* localedir;
	gboolean _tmp2_ = FALSE;
	const gchar* _tmp3_;
	gboolean _tmp5_;
	const gchar* _tmp7_ = NULL;
	gchar* _tmp8_;
	gchar* language;
	gboolean _tmp9_ = FALSE;
	const gchar* _tmp10_;
	gboolean _tmp12_;
	const gchar* _tmp14_;
	_tmp0_ = g_getenv ("DEJA_DUP_LOCALEDIR");
	_tmp1_ = g_strdup (_tmp0_);
	localedir = _tmp1_;
	_tmp3_ = localedir;
	if (_tmp3_ == NULL) {
		_tmp2_ = TRUE;
	} else {
		const gchar* _tmp4_;
		_tmp4_ = localedir;
		_tmp2_ = g_strcmp0 (_tmp4_, "") == 0;
	}
	_tmp5_ = _tmp2_;
	if (_tmp5_) {
		gchar* _tmp6_;
		_tmp6_ = g_strdup (LOCALE_DIR);
		_g_free0 (localedir);
		localedir = _tmp6_;
	}
	_tmp7_ = g_getenv ("DEJA_DUP_LANGUAGE");
	_tmp8_ = g_strdup (_tmp7_);
	language = _tmp8_;
	_tmp10_ = language;
	if (_tmp10_ != NULL) {
		const gchar* _tmp11_;
		_tmp11_ = language;
		_tmp9_ = g_strcmp0 (_tmp11_, "") != 0;
	} else {
		_tmp9_ = FALSE;
	}
	_tmp12_ = _tmp9_;
	if (_tmp12_) {
		const gchar* _tmp13_;
		_tmp13_ = language;
		g_setenv ("LANGUAGE", _tmp13_, TRUE);
	}
	textdomain (GETTEXT_PACKAGE);
	_tmp14_ = localedir;
	bindtextdomain (GETTEXT_PACKAGE, _tmp14_);
	bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
	_g_free0 (language);
	_g_free0 (localedir);
}


gchar* deja_dup_get_file_desc (GFile* file) {
	gchar* result = NULL;
	GFile* _tmp12_;
	gchar* _tmp13_ = NULL;
	gchar* _tmp14_;
	gchar* _tmp15_ = NULL;
	gchar* _tmp16_;
	gchar* desc;
	GFile* _tmp17_;
	gboolean _tmp18_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (file != NULL, NULL);
	{
		GFile* _tmp0_;
		GFileInfo* _tmp1_ = NULL;
		GFileInfo* info;
		GFileInfo* _tmp2_;
		gboolean _tmp3_ = FALSE;
		_tmp0_ = file;
		_tmp1_ = g_file_query_info (_tmp0_, G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME "," G_FILE_ATTRIBUTE_STANDARD_DESCRIPTION, G_FILE_QUERY_INFO_NONE, NULL, &_inner_error_);
		info = _tmp1_;
		if (_inner_error_ != NULL) {
			goto __catch18_g_error;
		}
		_tmp2_ = info;
		_tmp3_ = g_file_info_has_attribute (_tmp2_, G_FILE_ATTRIBUTE_STANDARD_DESCRIPTION);
		if (_tmp3_) {
			GFileInfo* _tmp4_;
			const gchar* _tmp5_ = NULL;
			gchar* _tmp6_;
			_tmp4_ = info;
			_tmp5_ = g_file_info_get_attribute_string (_tmp4_, G_FILE_ATTRIBUTE_STANDARD_DESCRIPTION);
			_tmp6_ = g_strdup (_tmp5_);
			result = _tmp6_;
			_g_object_unref0 (info);
			return result;
		} else {
			GFileInfo* _tmp7_;
			gboolean _tmp8_ = FALSE;
			_tmp7_ = info;
			_tmp8_ = g_file_info_has_attribute (_tmp7_, G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME);
			if (_tmp8_) {
				GFileInfo* _tmp9_;
				const gchar* _tmp10_ = NULL;
				gchar* _tmp11_;
				_tmp9_ = info;
				_tmp10_ = g_file_info_get_attribute_string (_tmp9_, G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME);
				_tmp11_ = g_strdup (_tmp10_);
				result = _tmp11_;
				_g_object_unref0 (info);
				return result;
			}
		}
		_g_object_unref0 (info);
	}
	goto __finally18;
	__catch18_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_g_error_free0 (e);
	}
	__finally18:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp12_ = file;
	_tmp13_ = g_file_get_parse_name (_tmp12_);
	_tmp14_ = _tmp13_;
	_tmp15_ = g_path_get_basename (_tmp14_);
	_tmp16_ = _tmp15_;
	_g_free0 (_tmp14_);
	desc = _tmp16_;
	_tmp17_ = file;
	_tmp18_ = g_file_is_native (_tmp17_);
	if (!_tmp18_) {
		GFile* _tmp19_;
		gchar* _tmp20_ = NULL;
		gchar* _tmp21_;
		DejaDupDecodedUri* _tmp22_ = NULL;
		DejaDupDecodedUri* _tmp23_;
		DejaDupDecodedUri* uri;
		gboolean _tmp24_ = FALSE;
		gboolean _tmp25_ = FALSE;
		DejaDupDecodedUri* _tmp26_;
		gboolean _tmp29_;
		gboolean _tmp32_;
		_tmp19_ = file;
		_tmp20_ = g_file_get_uri (_tmp19_);
		_tmp21_ = _tmp20_;
		_tmp22_ = deja_dup_decoded_uri_decode_uri (_tmp21_);
		_tmp23_ = _tmp22_;
		_g_free0 (_tmp21_);
		uri = _tmp23_;
		_tmp26_ = uri;
		if (_tmp26_ != NULL) {
			DejaDupDecodedUri* _tmp27_;
			const gchar* _tmp28_;
			_tmp27_ = uri;
			_tmp28_ = _tmp27_->host;
			_tmp25_ = _tmp28_ != NULL;
		} else {
			_tmp25_ = FALSE;
		}
		_tmp29_ = _tmp25_;
		if (_tmp29_) {
			DejaDupDecodedUri* _tmp30_;
			const gchar* _tmp31_;
			_tmp30_ = uri;
			_tmp31_ = _tmp30_->host;
			_tmp24_ = g_strcmp0 (_tmp31_, "") != 0;
		} else {
			_tmp24_ = FALSE;
		}
		_tmp32_ = _tmp24_;
		if (_tmp32_) {
			const gchar* _tmp33_ = NULL;
			const gchar* _tmp34_;
			DejaDupDecodedUri* _tmp35_;
			const gchar* _tmp36_;
			gchar* _tmp37_ = NULL;
			_tmp33_ = _ ("%1$s on %2$s");
			_tmp34_ = desc;
			_tmp35_ = uri;
			_tmp36_ = _tmp35_->host;
			_tmp37_ = g_strdup_printf (_tmp33_, _tmp34_, _tmp36_);
			_g_free0 (desc);
			desc = _tmp37_;
		}
		_deja_dup_decoded_uri_free0 (uri);
	}
	result = desc;
	return result;
}


void deja_dup_ensure_special_paths (void) {
	GFile* _tmp0_;
	_tmp0_ = deja_dup_home;
	if (_tmp0_ == NULL) {
		const gchar* _tmp1_ = NULL;
		GFile* _tmp2_ = NULL;
		gchar* _tmp3_ = NULL;
		gchar* _tmp4_;
		GFile* _tmp5_ = NULL;
		_tmp1_ = g_get_home_dir ();
		_tmp2_ = g_file_new_for_path (_tmp1_);
		_g_object_unref0 (deja_dup_home);
		deja_dup_home = _tmp2_;
		_tmp3_ = deja_dup_get_trash_path ();
		_tmp4_ = _tmp3_;
		_tmp5_ = g_file_new_for_path (_tmp4_);
		_g_object_unref0 (deja_dup_trash);
		deja_dup_trash = _tmp5_;
		_g_free0 (_tmp4_);
	}
}


gchar* deja_dup_get_display_name (GFile* f) {
	gchar* result = NULL;
	GFile* _tmp0_;
	GFile* _tmp1_;
	gboolean _tmp2_ = FALSE;
	GFile* _tmp14_;
	gchar* _tmp15_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (f != NULL, NULL);
	deja_dup_ensure_special_paths ();
	_tmp0_ = f;
	_tmp1_ = deja_dup_home;
	_tmp2_ = g_file_has_prefix (_tmp0_, _tmp1_);
	if (_tmp2_) {
		GFile* _tmp3_;
		GFile* _tmp4_;
		gchar* _tmp5_ = NULL;
		gchar* s;
		_tmp3_ = deja_dup_home;
		_tmp4_ = f;
		_tmp5_ = g_file_get_relative_path (_tmp3_, _tmp4_);
		s = _tmp5_;
		{
			const gchar* _tmp6_;
			const gchar* _tmp7_;
			gint _tmp8_;
			gint _tmp9_;
			gchar* _tmp10_ = NULL;
			gchar* _tmp11_;
			_tmp6_ = s;
			_tmp7_ = s;
			_tmp8_ = strlen (_tmp7_);
			_tmp9_ = _tmp8_;
			_tmp10_ = g_filename_to_utf8 (_tmp6_, (gssize) _tmp9_, NULL, NULL, &_inner_error_);
			_tmp11_ = _tmp10_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == G_CONVERT_ERROR) {
					goto __catch19_g_convert_error;
				}
				_g_free0 (s);
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
			result = _tmp11_;
			_g_free0 (s);
			return result;
		}
		goto __finally19;
		__catch19_g_convert_error:
		{
			GError* e = NULL;
			GError* _tmp12_;
			const gchar* _tmp13_;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp12_ = e;
			_tmp13_ = _tmp12_->message;
			g_warning ("CommonUtils.vala:569: %s\n", _tmp13_);
			_g_error_free0 (e);
		}
		__finally19:
		if (_inner_error_ != NULL) {
			_g_free0 (s);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_free0 (s);
	}
	_tmp14_ = f;
	_tmp15_ = g_file_get_parse_name (_tmp14_);
	result = _tmp15_;
	return result;
}


static void deja_dup_get_nickname_data_free (gpointer _data) {
	DejaDupGetNicknameData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->f);
	_g_free0 (_data_->result);
	g_slice_free (DejaDupGetNicknameData, _data_);
}


void deja_dup_get_nickname (GFile* f, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	DejaDupGetNicknameData* _data_;
	GFile* _tmp0_;
	GFile* _tmp1_;
	_data_ = g_slice_new0 (DejaDupGetNicknameData);
	_data_->_async_result = g_simple_async_result_new (g_object_newv (G_TYPE_OBJECT, 0, NULL), _callback_, _user_data_, deja_dup_get_nickname);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, deja_dup_get_nickname_data_free);
	_tmp0_ = f;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_data_->f = _tmp1_;
	deja_dup_get_nickname_co (_data_);
}


gchar* deja_dup_get_nickname_finish (GAsyncResult* _res_) {
	gchar* result;
	DejaDupGetNicknameData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
	result = _data_->result;
	_data_->result = NULL;
	return result;
}


static void deja_dup_get_nickname_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	DejaDupGetNicknameData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	deja_dup_get_nickname_co (_data_);
}


static gboolean deja_dup_get_nickname_co (DejaDupGetNicknameData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	deja_dup_ensure_special_paths ();
	_data_->_tmp0_ = _data_->f;
	_data_->_tmp1_ = deja_dup_home;
	_data_->_tmp2_ = FALSE;
	_data_->_tmp2_ = g_file_equal (_data_->_tmp0_, _data_->_tmp1_);
	if (_data_->_tmp2_) {
		{
			_data_->_tmp3_ = _data_->f;
			_data_->_state_ = 1;
			g_file_query_info_async (_data_->_tmp3_, G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS, G_PRIORITY_DEFAULT, NULL, deja_dup_get_nickname_ready, _data_);
			return FALSE;
			_state_1:
			_data_->_tmp4_ = NULL;
			_data_->_tmp4_ = g_file_query_info_finish (_data_->_tmp3_, _data_->_res_, &_data_->_inner_error_);
			_data_->info = _data_->_tmp4_;
			if (_data_->_inner_error_ != NULL) {
				goto __catch20_g_error;
			}
			_data_->_tmp5_ = NULL;
			_data_->_tmp5_ = _ ("Home (%s)");
			_data_->_tmp6_ = _data_->info;
			_data_->_tmp7_ = NULL;
			_data_->_tmp7_ = g_file_info_get_display_name (_data_->_tmp6_);
			_data_->_tmp8_ = NULL;
			_data_->_tmp8_ = g_strdup_printf (_data_->_tmp5_, _data_->_tmp7_);
			_g_free0 (_data_->s);
			_data_->s = _data_->_tmp8_;
			_g_object_unref0 (_data_->info);
		}
		goto __finally20;
		__catch20_g_error:
		{
			_data_->e = _data_->_inner_error_;
			_data_->_inner_error_ = NULL;
			_data_->_tmp9_ = _data_->e;
			_data_->_tmp10_ = _data_->_tmp9_->message;
			g_warning ("CommonUtils.vala:593: %s\n", _data_->_tmp10_);
			_data_->_tmp11_ = NULL;
			_data_->_tmp11_ = _ ("Home");
			_data_->_tmp12_ = g_strdup (_data_->_tmp11_);
			_g_free0 (_data_->s);
			_data_->s = _data_->_tmp12_;
			_g_error_free0 (_data_->e);
		}
		__finally20:
		if (_data_->_inner_error_ != NULL) {
			_g_free0 (_data_->s);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	} else {
		_data_->_tmp13_ = _data_->f;
		_data_->_tmp14_ = deja_dup_trash;
		_data_->_tmp15_ = FALSE;
		_data_->_tmp15_ = g_file_equal (_data_->_tmp13_, _data_->_tmp14_);
		if (_data_->_tmp15_) {
			_data_->_tmp16_ = NULL;
			_data_->_tmp16_ = _ ("Trash");
			_data_->_tmp17_ = g_strdup (_data_->_tmp16_);
			_g_free0 (_data_->s);
			_data_->s = _data_->_tmp17_;
		} else {
			_data_->_tmp18_ = _data_->f;
			_data_->_tmp19_ = NULL;
			_data_->_tmp19_ = deja_dup_get_display_name (_data_->_tmp18_);
			_g_free0 (_data_->s);
			_data_->s = _data_->_tmp19_;
		}
	}
	_data_->result = _data_->s;
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
	_g_free0 (_data_->s);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


gint deja_dup_get_full_backup_threshold (void) {
	gint result = 0;
	DejaDupSimpleSettings* _tmp0_ = NULL;
	DejaDupSimpleSettings* settings;
	DejaDupSimpleSettings* _tmp1_;
	gint _tmp2_ = 0;
	gint threshold;
	gint _tmp3_;
	_tmp0_ = deja_dup_get_settings (NULL);
	settings = _tmp0_;
	_tmp1_ = settings;
	_tmp2_ = g_settings_get_int ((GSettings*) _tmp1_, DEJA_DUP_FULL_BACKUP_PERIOD_KEY);
	threshold = _tmp2_;
	_tmp3_ = threshold;
	if (_tmp3_ < 1) {
		threshold = 84;
	}
	result = threshold;
	_g_object_unref0 (settings);
	return result;
}


void deja_dup_get_full_backup_threshold_date (GDate* result) {
	GTimeVal now = {0};
	GDate date = {0};
	GTimeVal _tmp0_;
	gint _tmp1_ = 0;
	gint days;
	g_get_current_time (&now);
	g_get_current_time (&now);
	memset (&date, 0, sizeof (GDate));
	_tmp0_ = now;
	g_date_set_time_val (&date, &_tmp0_);
	_tmp1_ = deja_dup_get_full_backup_threshold ();
	days = _tmp1_;
	g_date_subtract_days (&date, (guint) days);
	*result = date;
	return;
}



