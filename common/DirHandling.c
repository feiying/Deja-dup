/* DirHandling.c generated by valac 0.16.1, the Vala compiler
 * generated from DirHandling.vala, do not modify */

/* -*- Mode: Vala; indent-tabs-mode: nil; tab-width: 2 -*- */
/*
    This file is part of Déjà Dup.
    For copyright information, see AUTHORS.

    Déjà Dup is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Déjà Dup is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Déjà Dup.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>

#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))



gchar* deja_dup_get_trash_path (void);
GFile* deja_dup_parse_dir (const gchar* dir);
GFile** deja_dup_parse_dir_list (const gchar** dirs, int dirs_length1, int* result_length1);
static void _vala_array_add1 (GFile*** array, int* length, int* size, GFile* value);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


gchar* deja_dup_get_trash_path (void) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	_tmp0_ = g_get_user_data_dir ();
	_tmp1_ = g_build_filename (_tmp0_, "Trash", NULL);
	result = _tmp1_;
	return result;
}


GFile* deja_dup_parse_dir (const gchar* dir) {
	GFile* result = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* s;
	const gchar* _tmp2_;
	const gchar* _tmp44_;
	g_return_val_if_fail (dir != NULL, NULL);
	_tmp0_ = dir;
	_tmp1_ = g_strdup (_tmp0_);
	s = _tmp1_;
	_tmp2_ = s;
	if (g_strcmp0 (_tmp2_, "$HOME") == 0) {
		const gchar* _tmp3_ = NULL;
		gchar* _tmp4_;
		_tmp3_ = g_get_home_dir ();
		_tmp4_ = g_strdup (_tmp3_);
		_g_free0 (s);
		s = _tmp4_;
	} else {
		const gchar* _tmp5_;
		_tmp5_ = s;
		if (g_strcmp0 (_tmp5_, "$DESKTOP") == 0) {
			const gchar* _tmp6_ = NULL;
			gchar* _tmp7_;
			_tmp6_ = g_get_user_special_dir (G_USER_DIRECTORY_DESKTOP);
			_tmp7_ = g_strdup (_tmp6_);
			_g_free0 (s);
			s = _tmp7_;
		} else {
			const gchar* _tmp8_;
			_tmp8_ = s;
			if (g_strcmp0 (_tmp8_, "$DOCUMENTS") == 0) {
				const gchar* _tmp9_ = NULL;
				gchar* _tmp10_;
				_tmp9_ = g_get_user_special_dir (G_USER_DIRECTORY_DOCUMENTS);
				_tmp10_ = g_strdup (_tmp9_);
				_g_free0 (s);
				s = _tmp10_;
			} else {
				const gchar* _tmp11_;
				_tmp11_ = s;
				if (g_strcmp0 (_tmp11_, "$DOWNLOAD") == 0) {
					const gchar* _tmp12_ = NULL;
					gchar* _tmp13_;
					_tmp12_ = g_get_user_special_dir (G_USER_DIRECTORY_DOWNLOAD);
					_tmp13_ = g_strdup (_tmp12_);
					_g_free0 (s);
					s = _tmp13_;
				} else {
					const gchar* _tmp14_;
					_tmp14_ = s;
					if (g_strcmp0 (_tmp14_, "$MUSIC") == 0) {
						const gchar* _tmp15_ = NULL;
						gchar* _tmp16_;
						_tmp15_ = g_get_user_special_dir (G_USER_DIRECTORY_MUSIC);
						_tmp16_ = g_strdup (_tmp15_);
						_g_free0 (s);
						s = _tmp16_;
					} else {
						const gchar* _tmp17_;
						_tmp17_ = s;
						if (g_strcmp0 (_tmp17_, "$PICTURES") == 0) {
							const gchar* _tmp18_ = NULL;
							gchar* _tmp19_;
							_tmp18_ = g_get_user_special_dir (G_USER_DIRECTORY_PICTURES);
							_tmp19_ = g_strdup (_tmp18_);
							_g_free0 (s);
							s = _tmp19_;
						} else {
							const gchar* _tmp20_;
							_tmp20_ = s;
							if (g_strcmp0 (_tmp20_, "$PUBLIC_SHARE") == 0) {
								const gchar* _tmp21_ = NULL;
								gchar* _tmp22_;
								_tmp21_ = g_get_user_special_dir (G_USER_DIRECTORY_PUBLIC_SHARE);
								_tmp22_ = g_strdup (_tmp21_);
								_g_free0 (s);
								s = _tmp22_;
							} else {
								const gchar* _tmp23_;
								_tmp23_ = s;
								if (g_strcmp0 (_tmp23_, "$TEMPLATES") == 0) {
									const gchar* _tmp24_ = NULL;
									gchar* _tmp25_;
									_tmp24_ = g_get_user_special_dir (G_USER_DIRECTORY_TEMPLATES);
									_tmp25_ = g_strdup (_tmp24_);
									_g_free0 (s);
									s = _tmp25_;
								} else {
									const gchar* _tmp26_;
									_tmp26_ = s;
									if (g_strcmp0 (_tmp26_, "$TRASH") == 0) {
										gchar* _tmp27_ = NULL;
										_tmp27_ = deja_dup_get_trash_path ();
										_g_free0 (s);
										s = _tmp27_;
									} else {
										const gchar* _tmp28_;
										_tmp28_ = s;
										if (g_strcmp0 (_tmp28_, "$VIDEOS") == 0) {
											const gchar* _tmp29_ = NULL;
											gchar* _tmp30_;
											_tmp29_ = g_get_user_special_dir (G_USER_DIRECTORY_VIDEOS);
											_tmp30_ = g_strdup (_tmp29_);
											_g_free0 (s);
											s = _tmp30_;
										} else {
											gboolean _tmp31_ = FALSE;
											const gchar* _tmp32_;
											gchar* _tmp33_ = NULL;
											gchar* _tmp34_;
											gboolean _tmp35_;
											gboolean _tmp38_;
											_tmp32_ = s;
											_tmp33_ = g_uri_parse_scheme (_tmp32_);
											_tmp34_ = _tmp33_;
											_tmp35_ = _tmp34_ == NULL;
											_g_free0 (_tmp34_);
											if (_tmp35_) {
												const gchar* _tmp36_;
												gboolean _tmp37_ = FALSE;
												_tmp36_ = s;
												_tmp37_ = g_path_is_absolute (_tmp36_);
												_tmp31_ = !_tmp37_;
											} else {
												_tmp31_ = FALSE;
											}
											_tmp38_ = _tmp31_;
											if (_tmp38_) {
												const gchar* _tmp39_ = NULL;
												const gchar* _tmp40_;
												gchar* _tmp41_ = NULL;
												_tmp39_ = g_get_home_dir ();
												_tmp40_ = s;
												_tmp41_ = g_build_filename (_tmp39_, _tmp40_, NULL);
												_g_free0 (s);
												s = _tmp41_;
											} else {
												const gchar* _tmp42_;
												GFile* _tmp43_ = NULL;
												_tmp42_ = s;
												_tmp43_ = g_file_parse_name (_tmp42_);
												result = _tmp43_;
												_g_free0 (s);
												return result;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	_tmp44_ = s;
	if (_tmp44_ != NULL) {
		const gchar* _tmp45_;
		GFile* _tmp46_ = NULL;
		_tmp45_ = s;
		_tmp46_ = g_file_new_for_path (_tmp45_);
		result = _tmp46_;
		_g_free0 (s);
		return result;
	} else {
		result = NULL;
		_g_free0 (s);
		return result;
	}
	_g_free0 (s);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _vala_array_add1 (GFile*** array, int* length, int* size, GFile* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (GFile*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


GFile** deja_dup_parse_dir_list (const gchar** dirs, int dirs_length1, int* result_length1) {
	GFile** result = NULL;
	GFile** _tmp0_ = NULL;
	GFile** rv;
	gint rv_length1;
	gint _rv_size_;
	const gchar** _tmp1_;
	gint _tmp1__length1;
	GFile** _tmp9_;
	gint _tmp9__length1;
	_tmp0_ = g_new0 (GFile*, 0 + 1);
	rv = _tmp0_;
	rv_length1 = 0;
	_rv_size_ = rv_length1;
	_tmp1_ = dirs;
	_tmp1__length1 = dirs_length1;
	{
		const gchar** s_collection = NULL;
		gint s_collection_length1 = 0;
		gint _s_collection_size_ = 0;
		gint s_it = 0;
		s_collection = _tmp1_;
		s_collection_length1 = _tmp1__length1;
		for (s_it = 0; s_it < _tmp1__length1; s_it = s_it + 1) {
			gchar* _tmp2_;
			gchar* s = NULL;
			_tmp2_ = g_strdup ((gchar*) s_collection[s_it]);
			s = _tmp2_;
			{
				const gchar* _tmp3_;
				GFile* _tmp4_ = NULL;
				GFile* f;
				GFile* _tmp5_;
				_tmp3_ = s;
				_tmp4_ = deja_dup_parse_dir (_tmp3_);
				f = _tmp4_;
				_tmp5_ = f;
				if (_tmp5_ != NULL) {
					GFile** _tmp6_;
					gint _tmp6__length1;
					GFile* _tmp7_;
					GFile* _tmp8_;
					_tmp6_ = rv;
					_tmp6__length1 = rv_length1;
					_tmp7_ = f;
					_tmp8_ = _g_object_ref0 (_tmp7_);
					_vala_array_add1 (&rv, &rv_length1, &_rv_size_, _tmp8_);
				}
				_g_object_unref0 (f);
				_g_free0 (s);
			}
		}
	}
	_tmp9_ = rv;
	_tmp9__length1 = rv_length1;
	if (result_length1) {
		*result_length1 = _tmp9__length1;
	}
	result = _tmp9_;
	return result;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



