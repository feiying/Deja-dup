/* RecursiveDelete.c generated by valac 0.16.1, the Vala compiler
 * generated from RecursiveDelete.vala, do not modify */

/* -*- Mode: Vala; indent-tabs-mode: nil; tab-width: 2 -*- */
/*
    This file is part of Déjà Dup.
    For copyright information, see AUTHORS.

    Déjà Dup is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Déjà Dup is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Déjà Dup.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <glib.h>
#include <glib-object.h>
#include <gio/gio.h>
#include <stdlib.h>
#include <string.h>


#define DEJA_DUP_TYPE_RECURSIVE_OP (deja_dup_recursive_op_get_type ())
#define DEJA_DUP_RECURSIVE_OP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DEJA_DUP_TYPE_RECURSIVE_OP, DejaDupRecursiveOp))
#define DEJA_DUP_RECURSIVE_OP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DEJA_DUP_TYPE_RECURSIVE_OP, DejaDupRecursiveOpClass))
#define DEJA_DUP_IS_RECURSIVE_OP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DEJA_DUP_TYPE_RECURSIVE_OP))
#define DEJA_DUP_IS_RECURSIVE_OP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DEJA_DUP_TYPE_RECURSIVE_OP))
#define DEJA_DUP_RECURSIVE_OP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DEJA_DUP_TYPE_RECURSIVE_OP, DejaDupRecursiveOpClass))

typedef struct _DejaDupRecursiveOp DejaDupRecursiveOp;
typedef struct _DejaDupRecursiveOpClass DejaDupRecursiveOpClass;
typedef struct _DejaDupRecursiveOpPrivate DejaDupRecursiveOpPrivate;

#define DEJA_DUP_TYPE_RECURSIVE_DELETE (deja_dup_recursive_delete_get_type ())
#define DEJA_DUP_RECURSIVE_DELETE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DEJA_DUP_TYPE_RECURSIVE_DELETE, DejaDupRecursiveDelete))
#define DEJA_DUP_RECURSIVE_DELETE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DEJA_DUP_TYPE_RECURSIVE_DELETE, DejaDupRecursiveDeleteClass))
#define DEJA_DUP_IS_RECURSIVE_DELETE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DEJA_DUP_TYPE_RECURSIVE_DELETE))
#define DEJA_DUP_IS_RECURSIVE_DELETE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DEJA_DUP_TYPE_RECURSIVE_DELETE))
#define DEJA_DUP_RECURSIVE_DELETE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DEJA_DUP_TYPE_RECURSIVE_DELETE, DejaDupRecursiveDeleteClass))

typedef struct _DejaDupRecursiveDelete DejaDupRecursiveDelete;
typedef struct _DejaDupRecursiveDeleteClass DejaDupRecursiveDeleteClass;
typedef struct _DejaDupRecursiveDeletePrivate DejaDupRecursiveDeletePrivate;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

struct _DejaDupRecursiveOp {
	GObject parent_instance;
	DejaDupRecursiveOpPrivate * priv;
	GFileType src_type;
	GFileType dst_type;
};

struct _DejaDupRecursiveOpClass {
	GObjectClass parent_class;
	void (*handle_file) (DejaDupRecursiveOp* self);
	void (*handle_dir) (DejaDupRecursiveOp* self);
	void (*finish_dir) (DejaDupRecursiveOp* self);
	DejaDupRecursiveOp* (*clone_for_info) (DejaDupRecursiveOp* self, GFileInfo* info);
};

struct _DejaDupRecursiveDelete {
	DejaDupRecursiveOp parent_instance;
	DejaDupRecursiveDeletePrivate * priv;
};

struct _DejaDupRecursiveDeleteClass {
	DejaDupRecursiveOpClass parent_class;
};


static gpointer deja_dup_recursive_delete_parent_class = NULL;

GType deja_dup_recursive_op_get_type (void) G_GNUC_CONST;
GType deja_dup_recursive_delete_get_type (void) G_GNUC_CONST;
enum  {
	DEJA_DUP_RECURSIVE_DELETE_DUMMY_PROPERTY
};
DejaDupRecursiveDelete* deja_dup_recursive_delete_new (GFile* source);
DejaDupRecursiveDelete* deja_dup_recursive_delete_construct (GType object_type, GFile* source);
static void deja_dup_recursive_delete_real_handle_file (DejaDupRecursiveOp* base);
GFile* deja_dup_recursive_op_get_src (DejaDupRecursiveOp* self);
GFile* deja_dup_recursive_op_get_dst (DejaDupRecursiveOp* self);
static void deja_dup_recursive_delete_real_finish_dir (DejaDupRecursiveOp* base);
static DejaDupRecursiveOp* deja_dup_recursive_delete_real_clone_for_info (DejaDupRecursiveOp* base, GFileInfo* info);


DejaDupRecursiveDelete* deja_dup_recursive_delete_construct (GType object_type, GFile* source) {
	DejaDupRecursiveDelete * self = NULL;
	GFile* _tmp0_;
	g_return_val_if_fail (source != NULL, NULL);
	_tmp0_ = source;
	self = (DejaDupRecursiveDelete*) g_object_new (object_type, "src", _tmp0_, NULL);
	return self;
}


DejaDupRecursiveDelete* deja_dup_recursive_delete_new (GFile* source) {
	return deja_dup_recursive_delete_construct (DEJA_DUP_TYPE_RECURSIVE_DELETE, source);
}


static void deja_dup_recursive_delete_real_handle_file (DejaDupRecursiveOp* base) {
	DejaDupRecursiveDelete * self;
	GError * _inner_error_ = NULL;
	self = (DejaDupRecursiveDelete*) base;
	{
		GFile* _tmp0_;
		GFile* _tmp1_;
		_tmp0_ = deja_dup_recursive_op_get_src ((DejaDupRecursiveOp*) self);
		_tmp1_ = _tmp0_;
		g_file_delete (_tmp1_, NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch30_g_error;
		}
	}
	goto __finally30;
	__catch30_g_error:
	{
		GError* e = NULL;
		GFile* _tmp2_;
		GFile* _tmp3_;
		GFile* _tmp4_;
		GFile* _tmp5_;
		GError* _tmp6_;
		const gchar* _tmp7_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp2_ = deja_dup_recursive_op_get_src ((DejaDupRecursiveOp*) self);
		_tmp3_ = _tmp2_;
		_tmp4_ = deja_dup_recursive_op_get_dst ((DejaDupRecursiveOp*) self);
		_tmp5_ = _tmp4_;
		_tmp6_ = e;
		_tmp7_ = _tmp6_->message;
		g_signal_emit_by_name ((DejaDupRecursiveOp*) self, "raise-error", _tmp3_, _tmp5_, _tmp7_);
		_g_error_free0 (e);
	}
	__finally30:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void deja_dup_recursive_delete_real_finish_dir (DejaDupRecursiveOp* base) {
	DejaDupRecursiveDelete * self;
	GError * _inner_error_ = NULL;
	self = (DejaDupRecursiveDelete*) base;
	{
		GFile* _tmp0_;
		GFile* _tmp1_;
		_tmp0_ = deja_dup_recursive_op_get_src ((DejaDupRecursiveOp*) self);
		_tmp1_ = _tmp0_;
		g_file_delete (_tmp1_, NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch31_g_error;
		}
	}
	goto __finally31;
	__catch31_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_g_error_free0 (e);
	}
	__finally31:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static DejaDupRecursiveOp* deja_dup_recursive_delete_real_clone_for_info (DejaDupRecursiveOp* base, GFileInfo* info) {
	DejaDupRecursiveDelete * self;
	DejaDupRecursiveOp* result = NULL;
	GFileInfo* _tmp0_;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* child_name;
	GFile* _tmp3_;
	GFile* _tmp4_;
	GFile* _tmp5_ = NULL;
	GFile* src_child;
	DejaDupRecursiveDelete* _tmp6_;
	self = (DejaDupRecursiveDelete*) base;
	g_return_val_if_fail (info != NULL, NULL);
	_tmp0_ = info;
	_tmp1_ = g_file_info_get_name (_tmp0_);
	_tmp2_ = g_strdup (_tmp1_);
	child_name = _tmp2_;
	_tmp3_ = deja_dup_recursive_op_get_src ((DejaDupRecursiveOp*) self);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_file_get_child (_tmp4_, child_name);
	src_child = _tmp5_;
	_tmp6_ = deja_dup_recursive_delete_new (src_child);
	result = (DejaDupRecursiveOp*) _tmp6_;
	_g_object_unref0 (src_child);
	_g_free0 (child_name);
	return result;
}


static void deja_dup_recursive_delete_class_init (DejaDupRecursiveDeleteClass * klass) {
	deja_dup_recursive_delete_parent_class = g_type_class_peek_parent (klass);
	DEJA_DUP_RECURSIVE_OP_CLASS (klass)->handle_file = deja_dup_recursive_delete_real_handle_file;
	DEJA_DUP_RECURSIVE_OP_CLASS (klass)->finish_dir = deja_dup_recursive_delete_real_finish_dir;
	DEJA_DUP_RECURSIVE_OP_CLASS (klass)->clone_for_info = deja_dup_recursive_delete_real_clone_for_info;
}


static void deja_dup_recursive_delete_instance_init (DejaDupRecursiveDelete * self) {
}


GType deja_dup_recursive_delete_get_type (void) {
	static volatile gsize deja_dup_recursive_delete_type_id__volatile = 0;
	if (g_once_init_enter (&deja_dup_recursive_delete_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (DejaDupRecursiveDeleteClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) deja_dup_recursive_delete_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (DejaDupRecursiveDelete), 0, (GInstanceInitFunc) deja_dup_recursive_delete_instance_init, NULL };
		GType deja_dup_recursive_delete_type_id;
		deja_dup_recursive_delete_type_id = g_type_register_static (DEJA_DUP_TYPE_RECURSIVE_OP, "DejaDupRecursiveDelete", &g_define_type_info, 0);
		g_once_init_leave (&deja_dup_recursive_delete_type_id__volatile, deja_dup_recursive_delete_type_id);
	}
	return deja_dup_recursive_delete_type_id__volatile;
}



