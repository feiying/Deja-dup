/* RecursiveMove.c generated by valac 0.16.1, the Vala compiler
 * generated from RecursiveMove.vala, do not modify */

/* -*- Mode: Vala; indent-tabs-mode: nil; tab-width: 2 -*- */
/*
    This file is part of Déjà Dup.
    For copyright information, see AUTHORS.

    Déjà Dup is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Déjà Dup is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Déjà Dup.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <glib.h>
#include <glib-object.h>
#include <gio/gio.h>
#include <stdlib.h>
#include <string.h>


#define DEJA_DUP_TYPE_RECURSIVE_OP (deja_dup_recursive_op_get_type ())
#define DEJA_DUP_RECURSIVE_OP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DEJA_DUP_TYPE_RECURSIVE_OP, DejaDupRecursiveOp))
#define DEJA_DUP_RECURSIVE_OP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DEJA_DUP_TYPE_RECURSIVE_OP, DejaDupRecursiveOpClass))
#define DEJA_DUP_IS_RECURSIVE_OP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DEJA_DUP_TYPE_RECURSIVE_OP))
#define DEJA_DUP_IS_RECURSIVE_OP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DEJA_DUP_TYPE_RECURSIVE_OP))
#define DEJA_DUP_RECURSIVE_OP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DEJA_DUP_TYPE_RECURSIVE_OP, DejaDupRecursiveOpClass))

typedef struct _DejaDupRecursiveOp DejaDupRecursiveOp;
typedef struct _DejaDupRecursiveOpClass DejaDupRecursiveOpClass;
typedef struct _DejaDupRecursiveOpPrivate DejaDupRecursiveOpPrivate;

#define DEJA_DUP_TYPE_RECURSIVE_MOVE (deja_dup_recursive_move_get_type ())
#define DEJA_DUP_RECURSIVE_MOVE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DEJA_DUP_TYPE_RECURSIVE_MOVE, DejaDupRecursiveMove))
#define DEJA_DUP_RECURSIVE_MOVE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DEJA_DUP_TYPE_RECURSIVE_MOVE, DejaDupRecursiveMoveClass))
#define DEJA_DUP_IS_RECURSIVE_MOVE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DEJA_DUP_TYPE_RECURSIVE_MOVE))
#define DEJA_DUP_IS_RECURSIVE_MOVE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DEJA_DUP_TYPE_RECURSIVE_MOVE))
#define DEJA_DUP_RECURSIVE_MOVE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DEJA_DUP_TYPE_RECURSIVE_MOVE, DejaDupRecursiveMoveClass))

typedef struct _DejaDupRecursiveMove DejaDupRecursiveMove;
typedef struct _DejaDupRecursiveMoveClass DejaDupRecursiveMoveClass;
typedef struct _DejaDupRecursiveMovePrivate DejaDupRecursiveMovePrivate;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

struct _DejaDupRecursiveOp {
	GObject parent_instance;
	DejaDupRecursiveOpPrivate * priv;
	GFileType src_type;
	GFileType dst_type;
};

struct _DejaDupRecursiveOpClass {
	GObjectClass parent_class;
	void (*handle_file) (DejaDupRecursiveOp* self);
	void (*handle_dir) (DejaDupRecursiveOp* self);
	void (*finish_dir) (DejaDupRecursiveOp* self);
	DejaDupRecursiveOp* (*clone_for_info) (DejaDupRecursiveOp* self, GFileInfo* info);
};

struct _DejaDupRecursiveMove {
	DejaDupRecursiveOp parent_instance;
	DejaDupRecursiveMovePrivate * priv;
};

struct _DejaDupRecursiveMoveClass {
	DejaDupRecursiveOpClass parent_class;
};


static gpointer deja_dup_recursive_move_parent_class = NULL;

GType deja_dup_recursive_op_get_type (void) G_GNUC_CONST;
GType deja_dup_recursive_move_get_type (void) G_GNUC_CONST;
enum  {
	DEJA_DUP_RECURSIVE_MOVE_DUMMY_PROPERTY
};
DejaDupRecursiveMove* deja_dup_recursive_move_new (GFile* source, GFile* dest);
DejaDupRecursiveMove* deja_dup_recursive_move_construct (GType object_type, GFile* source, GFile* dest);
static void deja_dup_recursive_move_progress_callback (DejaDupRecursiveMove* self, gint64 current_num_bytes, gint64 total_num_bytes);
static void deja_dup_recursive_move_real_handle_file (DejaDupRecursiveOp* base);
GFile* deja_dup_recursive_op_get_dst (DejaDupRecursiveOp* self);
GFile* deja_dup_recursive_op_get_src (DejaDupRecursiveOp* self);
static void _deja_dup_recursive_move_progress_callback_gfile_progress_callback (gint64 current_num_bytes, gint64 total_num_bytes, gpointer self);
static void deja_dup_recursive_move_real_handle_dir (DejaDupRecursiveOp* base);
static void deja_dup_recursive_move_real_finish_dir (DejaDupRecursiveOp* base);
static DejaDupRecursiveOp* deja_dup_recursive_move_real_clone_for_info (DejaDupRecursiveOp* base, GFileInfo* info);


DejaDupRecursiveMove* deja_dup_recursive_move_construct (GType object_type, GFile* source, GFile* dest) {
	DejaDupRecursiveMove * self = NULL;
	GFile* _tmp0_;
	GFile* _tmp1_;
	g_return_val_if_fail (source != NULL, NULL);
	g_return_val_if_fail (dest != NULL, NULL);
	_tmp0_ = source;
	_tmp1_ = dest;
	self = (DejaDupRecursiveMove*) g_object_new (object_type, "src", _tmp0_, "dst", _tmp1_, NULL);
	return self;
}


DejaDupRecursiveMove* deja_dup_recursive_move_new (GFile* source, GFile* dest) {
	return deja_dup_recursive_move_construct (DEJA_DUP_TYPE_RECURSIVE_MOVE, source, dest);
}


static void deja_dup_recursive_move_progress_callback (DejaDupRecursiveMove* self, gint64 current_num_bytes, gint64 total_num_bytes) {
	g_return_if_fail (self != NULL);
}


static void _deja_dup_recursive_move_progress_callback_gfile_progress_callback (gint64 current_num_bytes, gint64 total_num_bytes, gpointer self) {
	deja_dup_recursive_move_progress_callback (self, current_num_bytes, total_num_bytes);
}


static void deja_dup_recursive_move_real_handle_file (DejaDupRecursiveOp* base) {
	DejaDupRecursiveMove * self;
	GFileType _tmp0_;
	GError * _inner_error_ = NULL;
	self = (DejaDupRecursiveMove*) base;
	_tmp0_ = ((DejaDupRecursiveOp*) self)->dst_type;
	if (_tmp0_ == G_FILE_TYPE_DIRECTORY) {
		{
			GFile* _tmp1_;
			GFile* _tmp2_;
			_tmp1_ = deja_dup_recursive_op_get_dst ((DejaDupRecursiveOp*) self);
			_tmp2_ = _tmp1_;
			g_file_delete (_tmp2_, NULL, &_inner_error_);
			if (_inner_error_ != NULL) {
				goto __catch32_g_error;
			}
		}
		goto __finally32;
		__catch32_g_error:
		{
			GError* e = NULL;
			GFile* _tmp3_;
			GFile* _tmp4_;
			GFile* _tmp5_;
			GFile* _tmp6_;
			GError* _tmp7_;
			const gchar* _tmp8_;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp3_ = deja_dup_recursive_op_get_src ((DejaDupRecursiveOp*) self);
			_tmp4_ = _tmp3_;
			_tmp5_ = deja_dup_recursive_op_get_dst ((DejaDupRecursiveOp*) self);
			_tmp6_ = _tmp5_;
			_tmp7_ = e;
			_tmp8_ = _tmp7_->message;
			g_signal_emit_by_name ((DejaDupRecursiveOp*) self, "raise-error", _tmp4_, _tmp6_, _tmp8_);
			_g_error_free0 (e);
			return;
		}
		__finally32:
		if (_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	{
		GFile* _tmp9_;
		GFile* _tmp10_;
		GFile* _tmp11_;
		GFile* _tmp12_;
		_tmp9_ = deja_dup_recursive_op_get_src ((DejaDupRecursiveOp*) self);
		_tmp10_ = _tmp9_;
		_tmp11_ = deja_dup_recursive_op_get_dst ((DejaDupRecursiveOp*) self);
		_tmp12_ = _tmp11_;
		g_file_move (_tmp10_, _tmp12_, (G_FILE_COPY_ALL_METADATA | G_FILE_COPY_NOFOLLOW_SYMLINKS) | G_FILE_COPY_OVERWRITE, NULL, _deja_dup_recursive_move_progress_callback_gfile_progress_callback, self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (g_error_matches (_inner_error_, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED)) {
				goto __catch33_g_io_error_permission_denied;
			}
			goto __catch33_g_error;
		}
	}
	goto __finally33;
	__catch33_g_io_error_permission_denied:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			GFile* _tmp13_;
			GFile* _tmp14_;
			GFile* _tmp15_;
			GFile* _tmp16_;
			_tmp13_ = deja_dup_recursive_op_get_src ((DejaDupRecursiveOp*) self);
			_tmp14_ = _tmp13_;
			_tmp15_ = deja_dup_recursive_op_get_dst ((DejaDupRecursiveOp*) self);
			_tmp16_ = _tmp15_;
			g_file_copy (_tmp14_, _tmp16_, (G_FILE_COPY_ALL_METADATA | G_FILE_COPY_NOFOLLOW_SYMLINKS) | G_FILE_COPY_OVERWRITE, NULL, _deja_dup_recursive_move_progress_callback_gfile_progress_callback, self, &_inner_error_);
			if (_inner_error_ != NULL) {
				goto __catch34_g_error;
			}
		}
		goto __finally34;
		__catch34_g_error:
		{
			GError* e = NULL;
			GFile* _tmp17_;
			GFile* _tmp18_;
			GFile* _tmp19_;
			GFile* _tmp20_;
			GError* _tmp21_;
			const gchar* _tmp22_;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp17_ = deja_dup_recursive_op_get_src ((DejaDupRecursiveOp*) self);
			_tmp18_ = _tmp17_;
			_tmp19_ = deja_dup_recursive_op_get_dst ((DejaDupRecursiveOp*) self);
			_tmp20_ = _tmp19_;
			_tmp21_ = e;
			_tmp22_ = _tmp21_->message;
			g_signal_emit_by_name ((DejaDupRecursiveOp*) self, "raise-error", _tmp18_, _tmp20_, _tmp22_);
			_g_error_free0 (e);
		}
		__finally34:
		if (_inner_error_ != NULL) {
			_g_error_free0 (e);
			_g_error_free0 (e);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_g_error_free0 (e);
	}
	goto __finally33;
	__catch33_g_error:
	{
		GError* e = NULL;
		GFile* _tmp23_;
		GFile* _tmp24_;
		GFile* _tmp25_;
		GFile* _tmp26_;
		GError* _tmp27_;
		const gchar* _tmp28_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp23_ = deja_dup_recursive_op_get_src ((DejaDupRecursiveOp*) self);
		_tmp24_ = _tmp23_;
		_tmp25_ = deja_dup_recursive_op_get_dst ((DejaDupRecursiveOp*) self);
		_tmp26_ = _tmp25_;
		_tmp27_ = e;
		_tmp28_ = _tmp27_->message;
		g_signal_emit_by_name ((DejaDupRecursiveOp*) self, "raise-error", _tmp24_, _tmp26_, _tmp28_);
		_g_error_free0 (e);
	}
	__finally33:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void deja_dup_recursive_move_real_handle_dir (DejaDupRecursiveOp* base) {
	DejaDupRecursiveMove * self;
	gboolean _tmp0_ = FALSE;
	GFileType _tmp1_;
	gboolean _tmp3_;
	GFileType _tmp12_;
	GError * _inner_error_ = NULL;
	self = (DejaDupRecursiveMove*) base;
	_tmp1_ = ((DejaDupRecursiveOp*) self)->dst_type;
	if (_tmp1_ != G_FILE_TYPE_UNKNOWN) {
		GFileType _tmp2_;
		_tmp2_ = ((DejaDupRecursiveOp*) self)->dst_type;
		_tmp0_ = _tmp2_ != G_FILE_TYPE_DIRECTORY;
	} else {
		_tmp0_ = FALSE;
	}
	_tmp3_ = _tmp0_;
	if (_tmp3_) {
		{
			GFile* _tmp4_;
			GFile* _tmp5_;
			_tmp4_ = deja_dup_recursive_op_get_dst ((DejaDupRecursiveOp*) self);
			_tmp5_ = _tmp4_;
			g_file_delete (_tmp5_, NULL, &_inner_error_);
			if (_inner_error_ != NULL) {
				goto __catch35_g_error;
			}
		}
		goto __finally35;
		__catch35_g_error:
		{
			GError* e = NULL;
			GFile* _tmp6_;
			GFile* _tmp7_;
			GFile* _tmp8_;
			GFile* _tmp9_;
			GError* _tmp10_;
			const gchar* _tmp11_;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp6_ = deja_dup_recursive_op_get_src ((DejaDupRecursiveOp*) self);
			_tmp7_ = _tmp6_;
			_tmp8_ = deja_dup_recursive_op_get_dst ((DejaDupRecursiveOp*) self);
			_tmp9_ = _tmp8_;
			_tmp10_ = e;
			_tmp11_ = _tmp10_->message;
			g_signal_emit_by_name ((DejaDupRecursiveOp*) self, "raise-error", _tmp7_, _tmp9_, _tmp11_);
			_g_error_free0 (e);
			return;
		}
		__finally35:
		if (_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		((DejaDupRecursiveOp*) self)->dst_type = G_FILE_TYPE_UNKNOWN;
	}
	_tmp12_ = ((DejaDupRecursiveOp*) self)->dst_type;
	if (_tmp12_ == G_FILE_TYPE_UNKNOWN) {
		{
			GFile* _tmp13_;
			GFile* _tmp14_;
			_tmp13_ = deja_dup_recursive_op_get_dst ((DejaDupRecursiveOp*) self);
			_tmp14_ = _tmp13_;
			g_file_make_directory (_tmp14_, NULL, &_inner_error_);
			if (_inner_error_ != NULL) {
				goto __catch36_g_error;
			}
		}
		goto __finally36;
		__catch36_g_error:
		{
			GError* e = NULL;
			GFile* _tmp15_;
			GFile* _tmp16_;
			GFile* _tmp17_;
			GFile* _tmp18_;
			GError* _tmp19_;
			const gchar* _tmp20_;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp15_ = deja_dup_recursive_op_get_src ((DejaDupRecursiveOp*) self);
			_tmp16_ = _tmp15_;
			_tmp17_ = deja_dup_recursive_op_get_dst ((DejaDupRecursiveOp*) self);
			_tmp18_ = _tmp17_;
			_tmp19_ = e;
			_tmp20_ = _tmp19_->message;
			g_signal_emit_by_name ((DejaDupRecursiveOp*) self, "raise-error", _tmp16_, _tmp18_, _tmp20_);
			_g_error_free0 (e);
			return;
		}
		__finally36:
		if (_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
}


static void deja_dup_recursive_move_real_finish_dir (DejaDupRecursiveOp* base) {
	DejaDupRecursiveMove * self;
	GError * _inner_error_ = NULL;
	self = (DejaDupRecursiveMove*) base;
	{
		GFile* _tmp0_;
		GFile* _tmp1_;
		GFile* _tmp2_;
		GFile* _tmp3_;
		_tmp0_ = deja_dup_recursive_op_get_src ((DejaDupRecursiveOp*) self);
		_tmp1_ = _tmp0_;
		_tmp2_ = deja_dup_recursive_op_get_dst ((DejaDupRecursiveOp*) self);
		_tmp3_ = _tmp2_;
		g_file_copy_attributes (_tmp1_, _tmp3_, G_FILE_COPY_NOFOLLOW_SYMLINKS | G_FILE_COPY_ALL_METADATA, NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch37_g_error;
		}
	}
	goto __finally37;
	__catch37_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_g_error_free0 (e);
	}
	__finally37:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	{
		GFile* _tmp4_;
		GFile* _tmp5_;
		_tmp4_ = deja_dup_recursive_op_get_src ((DejaDupRecursiveOp*) self);
		_tmp5_ = _tmp4_;
		g_file_delete (_tmp5_, NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch38_g_error;
		}
	}
	goto __finally38;
	__catch38_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_g_error_free0 (e);
	}
	__finally38:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static DejaDupRecursiveOp* deja_dup_recursive_move_real_clone_for_info (DejaDupRecursiveOp* base, GFileInfo* info) {
	DejaDupRecursiveMove * self;
	DejaDupRecursiveOp* result = NULL;
	GFileInfo* _tmp0_;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* child_name;
	GFile* _tmp3_;
	GFile* _tmp4_;
	GFile* _tmp5_ = NULL;
	GFile* src_child;
	GFile* _tmp6_;
	GFile* _tmp7_;
	GFile* _tmp8_ = NULL;
	GFile* dst_child;
	DejaDupRecursiveMove* _tmp9_;
	self = (DejaDupRecursiveMove*) base;
	g_return_val_if_fail (info != NULL, NULL);
	_tmp0_ = info;
	_tmp1_ = g_file_info_get_name (_tmp0_);
	_tmp2_ = g_strdup (_tmp1_);
	child_name = _tmp2_;
	_tmp3_ = deja_dup_recursive_op_get_src ((DejaDupRecursiveOp*) self);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_file_get_child (_tmp4_, child_name);
	src_child = _tmp5_;
	_tmp6_ = deja_dup_recursive_op_get_dst ((DejaDupRecursiveOp*) self);
	_tmp7_ = _tmp6_;
	_tmp8_ = g_file_get_child (_tmp7_, child_name);
	dst_child = _tmp8_;
	_tmp9_ = deja_dup_recursive_move_new (src_child, dst_child);
	result = (DejaDupRecursiveOp*) _tmp9_;
	_g_object_unref0 (dst_child);
	_g_object_unref0 (src_child);
	_g_free0 (child_name);
	return result;
}


static void deja_dup_recursive_move_class_init (DejaDupRecursiveMoveClass * klass) {
	deja_dup_recursive_move_parent_class = g_type_class_peek_parent (klass);
	DEJA_DUP_RECURSIVE_OP_CLASS (klass)->handle_file = deja_dup_recursive_move_real_handle_file;
	DEJA_DUP_RECURSIVE_OP_CLASS (klass)->handle_dir = deja_dup_recursive_move_real_handle_dir;
	DEJA_DUP_RECURSIVE_OP_CLASS (klass)->finish_dir = deja_dup_recursive_move_real_finish_dir;
	DEJA_DUP_RECURSIVE_OP_CLASS (klass)->clone_for_info = deja_dup_recursive_move_real_clone_for_info;
}


static void deja_dup_recursive_move_instance_init (DejaDupRecursiveMove * self) {
}


/**
 * Recursively moves one directory into another, merging files.  And by merge,
 * I mean it overwrites.  It skips any files it can't move and reports an
 * error, but keeps going.
 *
 * This is not optimized for remote files.  It's mostly async, but it does the
 * occasional sync operation.
 */
GType deja_dup_recursive_move_get_type (void) {
	static volatile gsize deja_dup_recursive_move_type_id__volatile = 0;
	if (g_once_init_enter (&deja_dup_recursive_move_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (DejaDupRecursiveMoveClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) deja_dup_recursive_move_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (DejaDupRecursiveMove), 0, (GInstanceInitFunc) deja_dup_recursive_move_instance_init, NULL };
		GType deja_dup_recursive_move_type_id;
		deja_dup_recursive_move_type_id = g_type_register_static (DEJA_DUP_TYPE_RECURSIVE_OP, "DejaDupRecursiveMove", &g_define_type_info, 0);
		g_once_init_leave (&deja_dup_recursive_move_type_id__volatile, deja_dup_recursive_move_type_id);
	}
	return deja_dup_recursive_move_type_id__volatile;
}



